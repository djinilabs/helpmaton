import { resourceGone } from "@hapi/boom";
import type { ModelMessage } from "ai";
import { generateText, tool, stepCountIs } from "ai";
import { z } from "zod";

import { database } from "../../tables";
import { extractTokenUsage } from "../../utils/conversationLogger";
import {
  adjustCreditReservation,
  refundReservation,
} from "../../utils/creditManagement";
import { validateCreditsAndLimitsAndReserve } from "../../utils/creditValidation";
import { searchDocuments } from "../../utils/documentSearch";
import { isCreditDeductionEnabled } from "../../utils/featureFlags";
import { sendNotification } from "../../utils/notifications";

import { createMcpServerTools } from "./mcpUtils";
import { createModel } from "./modelFactory";
import type { Provider } from "./modelFactory";

export const MODEL_NAME = "google/gemini-2.5-flash";

export interface WorkspaceAndAgent {
  workspace: {
    pk: string;
    [key: string]: unknown;
  };
  agent: {
    pk: string;
    systemPrompt: string;
    notificationChannelId?: string;
    temperature?: number;
    topP?: number;
    topK?: number;
    maxOutputTokens?: number;
    stopSequences?: string[];
    maxToolRoundtrips?: number;
    [key: string]: unknown;
  };
}

/**
 * Get workspace API key if it exists for the specified provider
 * Supports backward compatibility: checks new format first, then old format
 */
export async function getWorkspaceApiKey(
  workspaceId: string,
  provider: Provider = "google"
): Promise<string | null> {
  const db = await database();
  const sk = "key";

  // Try new format first: workspace-api-keys/{workspaceId}/{provider}
  const newPk = `workspace-api-keys/${workspaceId}/${provider}`;
  try {
    const workspaceKey = await db["workspace-api-key"].get(newPk, sk);
    if (workspaceKey?.key) {
      return workspaceKey.key;
    }
  } catch {
    // Key doesn't exist in new format, continue to check old format
  }

  // Backward compatibility: check old format for Google provider only
  // Old format: workspace-api-keys/{workspaceId}
  if (provider === "google") {
    const oldPk = `workspace-api-keys/${workspaceId}`;
    try {
      const workspaceKey = await db["workspace-api-key"].get(oldPk, sk);
      if (workspaceKey?.key) {
        // Migrate to new format
        try {
          await db["workspace-api-key"].create({
            pk: newPk,
            sk,
            workspaceId,
            key: workspaceKey.key,
            provider: "google",
            createdBy: workspaceKey.createdBy,
            // Note: createdAt is auto-generated by the create method
            // During migration, the new key will have a new timestamp
          });
          // Delete old key after successful migration
          try {
            await db["workspace-api-key"].delete(oldPk, sk);
          } catch {
            // Ignore deletion errors
          }
        } catch {
          // Migration failed, but return the key anyway
        }
        return workspaceKey.key;
      }
    } catch {
      // Old key doesn't exist either
    }
  }

  return null;
}

/**
 * Create an AI model instance (OpenRouter by default, Google for backward compatibility)
 */
export async function createAgentModel(
  referer: string = "http://localhost:3000/api/webhook",
  apiKey?: string,
  modelName?: string,
  workspaceId?: string,
  agentId?: string,
  usesByok?: boolean,
  userId?: string,
  provider: Provider = "openrouter"
) {
  // Use provided modelName or fall back to default MODEL_NAME
  const finalModelName = modelName || MODEL_NAME;

  // Use createModel from modelFactory which handles OpenRouter and Google
  return createModel(provider, finalModelName, workspaceId, referer, userId);
}

/**
 * Build generateText options from agent configuration
 */
export function buildGenerateTextOptions(agent: {
  temperature?: number | null;
  topP?: number | null;
  topK?: number | null;
  maxOutputTokens?: number | null;
  stopSequences?: string[] | null;
  maxToolRoundtrips?: number | null;
  [key: string]: unknown;
}) {
  const options: {
    temperature?: number;
    topP?: number;
    topK?: number;
    maxTokens?: number;
    stopSequences?: string[];
    stopWhen?: ReturnType<typeof stepCountIs>;
  } = {};

  // Handle null/undefined values - only use defined, non-null values
  if (agent.temperature !== undefined && agent.temperature !== null) {
    options.temperature = agent.temperature;
  }
  if (agent.topP !== undefined && agent.topP !== null) {
    options.topP = agent.topP;
  }
  if (agent.topK !== undefined && agent.topK !== null) {
    options.topK = agent.topK;
  }
  if (agent.maxOutputTokens !== undefined && agent.maxOutputTokens !== null) {
    options.maxTokens = agent.maxOutputTokens;
  }
  if (
    agent.stopSequences !== undefined &&
    agent.stopSequences !== null &&
    agent.stopSequences.length > 0
  ) {
    options.stopSequences = agent.stopSequences;
  }
  if (
    agent.maxToolRoundtrips !== undefined &&
    agent.maxToolRoundtrips !== null
  ) {
    options.stopWhen = stepCountIs(agent.maxToolRoundtrips);
  } else {
    options.stopWhen = stepCountIs(5); // Default
  }

  // Log all model parameters before execution
  const maxToolRoundtrips = agent.maxToolRoundtrips ?? 5;
  console.log("[Model Configuration] Generated options:", {
    temperature: options.temperature ?? "default",
    topP: options.topP ?? "default",
    topK: options.topK ?? "default",
    maxTokens: options.maxTokens ?? "default",
    stopSequences: options.stopSequences ?? "none",
    maxToolRoundtrips,
    stopWhen: `stepCountIs(${maxToolRoundtrips})`,
    agentConfig: {
      temperature: agent.temperature,
      topP: agent.topP,
      topK: agent.topK,
      maxOutputTokens: agent.maxOutputTokens,
      stopSequences: agent.stopSequences,
      maxToolRoundtrips: agent.maxToolRoundtrips,
    },
  });

  return options;
}

/**
 * Validate that a workspace and agent exist and belong together
 */
export async function validateWorkspaceAndAgent(
  workspaceId: string,
  agentId: string
): Promise<WorkspaceAndAgent> {
  const db = await database();

  // Validate workspace exists
  const workspacePk = `workspaces/${workspaceId}`;
  const workspace = await db.workspace.get(workspacePk, "workspace");
  if (!workspace) {
    throw resourceGone("Workspace not found");
  }

  // Validate agent exists and belongs to workspace
  const agentPk = `agents/${workspaceId}/${agentId}`;
  const agent = await db.agent.get(agentPk, "agent");
  if (!agent) {
    throw resourceGone("Agent not found");
  }

  return { workspace, agent };
}

/**
 * Create the search_documents tool with customizable options
 */
export function createSearchDocumentsTool(
  workspaceId: string,
  options?: {
    description?: string;
    queryDescription?: string;
    formatResults?: (
      results: Array<{
        snippet: string;
        documentName: string;
        documentId: string;
        folderPath: string;
        similarity: number;
      }>
    ) => string;
    messages?: unknown[];
  }
) {
  const searchDocumentsParamsSchema = z.object({
    query: z
      .string()
      .min(1, "Query parameter is required and cannot be empty")
      .describe(
        options?.queryDescription ||
          "MANDATORY: The search terms to look for in the documents. Extract this directly from the user's request. If user says 'search for X', use query='X'. If user says 'find Y', use query='Y'. Always use the exact terms or keywords the user mentioned. This parameter is REQUIRED - you must always provide it when calling this tool."
      ),
    topN: z
      .number()
      .optional()
      .default(5)
      .describe("Number of top results to return (default: 5)"),
  });

  type SearchDocumentsArgs = z.infer<typeof searchDocumentsParamsSchema>;

  const defaultDescription =
    "Search workspace documents using semantic vector search. YOU MUST ALWAYS provide a 'query' parameter with the search terms. When the user asks to search for something, extract the search terms from their message and pass them as the 'query' parameter. Example: User says 'search for helpmaton' → call with {query: 'helpmaton'}. User says 'find information about scheduling' → call with {query: 'scheduling'}. User says 'look up API documentation' → call with {query: 'API documentation'}. The query parameter is MANDATORY and must contain the search terms the user wants to find.";

  const defaultFormatResults = (
    results: Array<{
      snippet: string;
      documentName: string;
      documentId: string;
      folderPath: string;
      similarity: number;
    }>
  ) => {
    return results.map((result) => result.snippet).join("\n\n---\n\n");
  };

  const formatResults = options?.formatResults || defaultFormatResults;

  return tool({
    description: options?.description || defaultDescription,
    parameters: searchDocumentsParamsSchema,
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment -- AI SDK tool function has type inference limitations when schema is extracted
    // @ts-ignore - The execute function signature doesn't match the expected type, but works at runtime
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    execute: async (args: any) => {
      const typedArgs = args as SearchDocumentsArgs;
      let query: string | undefined = typedArgs.query;
      const topN = typedArgs.topN ?? 5;

      // Log tool call with arguments
      console.log("[Tool Call] search_documents", {
        toolName: "search_documents",
        arguments: { query: typedArgs.query, topN: typedArgs.topN },
        workspaceId,
      });

      // Validate query
      if (!query || typeof query !== "string" || query.trim().length === 0) {
        // Try to extract query from the last user message as a fallback
        if (
          options?.messages &&
          Array.isArray(options.messages) &&
          options.messages.length > 0
        ) {
          const lastMessage = options.messages[options.messages.length - 1];
          if (lastMessage) {
            const messageText =
              typeof lastMessage === "object" && "content" in lastMessage
                ? String(lastMessage.content)
                : typeof lastMessage === "string"
                ? lastMessage
                : "";

            if (messageText) {
              // Try to extract search terms from the message
              const searchMatch = messageText.match(
                /(?:search|find|look).*?(?:for|about)\s+(.+?)(?:\s|$|and|tell)/i
              );
              if (searchMatch && searchMatch[1]) {
                query = searchMatch[1].trim();
              } else {
                // Try to get the main topic from the message
                const words = messageText
                  .split(/\s+/)
                  .filter((w) => w.length > 3);
                if (words.length > 0) {
                  query = words.slice(0, 3).join(" ");
                }
              }
            }
          }
        }

        // If still no query, return error
        if (!query || query.trim().length === 0) {
          return `Error: The search_documents tool requires a 'query' parameter with the search terms. Please call this tool with query='<search terms>' where <search terms> are the keywords you want to search for. For example, if the user asks to "search for timeclout", use query='timeclout'.`;
        }
      }

      try {
        const results = await searchDocuments(workspaceId, query, topN);

        let result: string;
        if (results.length === 0) {
          result = "No relevant documents found for the query.";
        } else {
          const formattedResults = formatResults(results);
          result = `Found ${results.length} relevant document snippet(s):\n\n${formattedResults}`;
        }

        // Log tool result
        console.log("[Tool Result] search_documents", {
          toolName: "search_documents",
          result,
          resultLength: result.length,
        });

        return result;
      } catch (error) {
        const errorMessage = `Error searching documents: ${
          error instanceof Error ? error.message : String(error)
        }`;
        console.error("[Tool Error] search_documents", {
          toolName: "search_documents",
          error: error instanceof Error ? error.message : String(error),
          arguments: { query: typedArgs.query, topN: typedArgs.topN },
        });
        return errorMessage;
      }
    },
  });
}

/**
 * Create the send_notification tool for sending notifications to configured channels
 */
export function createSendNotificationTool(
  workspaceId: string,
  channelId: string
) {
  const sendNotificationParamsSchema = z.object({
    content: z
      .string()
      .min(1, "Content parameter is required and cannot be empty")
      .describe(
        "REQUIRED: The notification message text to send. This MUST be a non-empty string containing the actual message content. This is the ONLY parameter required. The channel is pre-configured - you do NOT need and CANNOT provide a channel ID. Just put the message text here. Example: If user wants to send 'hello world', use content='hello world'. The message will be sent to the pre-configured channel automatically. NEVER call this tool with an empty string or without the content parameter."
      ),
  });

  type SendNotificationArgs = z.infer<typeof sendNotificationParamsSchema>;

  const description =
    "Send a notification message to the pre-configured channel. CRITICAL REQUIREMENTS: (1) The notification channel is already pre-configured - you NEVER need to ask the user for a channel ID or channel name. (2) You MUST provide a 'content' parameter with a non-empty string containing the actual message text. (3) Do NOT call this tool if the user hasn't specified what message to send - ask them what message they want to send first. (4) Do NOT ask the user for any channel information. When the user asks you to send a notification or message, IMMEDIATELY call this tool with the 'content' parameter containing the message text. Example: If user says 'send hello world', immediately call send_notification with content='hello world'. The channel is automatically configured and you cannot change it. If the user just says 'notify' without specifying what to send, ask them what message they want to send before calling this tool.";

  return tool({
    description,
    parameters: sendNotificationParamsSchema,
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment -- AI SDK tool function has type inference limitations when schema is extracted
    // @ts-ignore - The execute function signature doesn't match the expected type, but works at runtime
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    execute: async (args: any) => {
      const typedArgs = args as SendNotificationArgs;
      const content = typedArgs?.content;

      // Log tool call with arguments
      console.log("[Tool Call] send_notification", {
        toolName: "send_notification",
        arguments: {
          content: content
            ? `${content.substring(0, 100)}${content.length > 100 ? "..." : ""}`
            : undefined,
        },
        workspaceId,
        channelId,
      });

      // Validate content parameter
      if (!args || typeof args !== "object") {
        console.error("[send_notification] Invalid args object:", args);
        return "Error: The send_notification tool received invalid arguments. The 'content' parameter is required and must be a non-empty string containing the notification message.";
      }

      if (!("content" in args)) {
        console.error(
          "[send_notification] Missing 'content' parameter in args:",
          args
        );
        return "Error: The send_notification tool requires a 'content' parameter with the notification message. Please provide the message text in the 'content' parameter. Example: { content: 'Your message here' }";
      }

      if (
        !content ||
        typeof content !== "string" ||
        content.trim().length === 0
      ) {
        console.error("[send_notification] Invalid or empty content:", {
          content,
          type: typeof content,
          length: typeof content === "string" ? content.length : "N/A",
        });
        return "Error: The send_notification tool requires a 'content' parameter with a non-empty string containing the notification message. The content cannot be empty. Please provide the actual message text you want to send.";
      }

      try {
        const db = await database();
        const channelPk = `output-channels/${workspaceId}/${channelId}`;
        const channel = await db["output_channel"].get(channelPk, "channel");

        if (!channel) {
          const errorMessage = `Error: Notification channel not found. The configured channel may have been deleted.`;
          console.error("[Tool Error] send_notification", {
            toolName: "send_notification",
            error: "Channel not found",
            arguments: {
              content: content
                ? `${content.substring(0, 100)}${
                    content.length > 100 ? "..." : ""
                  }`
                : undefined,
            },
          });
          return errorMessage;
        }

        await sendNotification(channel, content.trim());

        const result = `✅ Notification successfully sent to ${channel.name} (${channel.type}). The message has been delivered to the configured notification channel.`;

        // Log tool result
        console.log("[Tool Result] send_notification", {
          toolName: "send_notification",
          result,
          channelName: channel.name,
          channelType: channel.type,
        });

        return result;
      } catch (error) {
        const errorMessage = `Error sending notification: ${
          error instanceof Error ? error.message : String(error)
        }`;
        console.error("[Tool Error] send_notification", {
          toolName: "send_notification",
          error: error instanceof Error ? error.message : String(error),
          arguments: {
            content: content
              ? `${content.substring(0, 100)}${
                  content.length > 100 ? "..." : ""
                }`
              : undefined,
          },
        });
        return errorMessage;
      }
    },
  });
}

/**
 * Create the send_email tool for sending emails via workspace email connection
 */
export function createSendEmailTool(workspaceId: string) {
  const sendEmailParamsSchema = z.object({
    to: z
      .string()
      .email("to must be a valid email address")
      .describe(
        "REQUIRED: The recipient email address. This MUST be a valid email address. Example: 'user@example.com'"
      ),
    subject: z
      .string()
      .min(1, "subject is required and cannot be empty")
      .describe(
        "REQUIRED: The email subject line. This MUST be a non-empty string. Example: 'Hello from Helpmaton'"
      ),
    text: z
      .string()
      .min(1, "text is required and cannot be empty")
      .describe(
        "REQUIRED: The plain text email body. This MUST be a non-empty string containing the email message content."
      ),
    html: z
      .string()
      .optional()
      .describe(
        "OPTIONAL: The HTML email body. If provided, this will be used instead of the plain text version for email clients that support HTML."
      ),
    from: z
      .string()
      .email("from must be a valid email address")
      .optional()
      .describe(
        "OPTIONAL: The sender email address. If not provided, the email connection's default sender will be used."
      ),
  });

  type SendEmailArgs = z.infer<typeof sendEmailParamsSchema>;

  const description =
    "Send an email message via the workspace's email connection. CRITICAL REQUIREMENTS: (1) The email connection is already pre-configured for the workspace - you NEVER need to ask the user for connection details. (2) You MUST provide 'to', 'subject', and 'text' parameters. (3) The 'to' parameter must be a valid email address. (4) The 'subject' and 'text' parameters must be non-empty strings. (5) When the user asks you to send an email, IMMEDIATELY call this tool with the required parameters. Example: If user says 'send an email to john@example.com with subject Hello and body Hi there', call send_email with {to: 'john@example.com', subject: 'Hello', text: 'Hi there'}. Do NOT ask the user for email connection information - it's already configured.";

  return tool({
    description,
    parameters: sendEmailParamsSchema,
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment -- AI SDK tool function has type inference limitations when schema is extracted
    // @ts-ignore - The execute function signature doesn't match the expected type, but works at runtime
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    execute: async (args: any) => {
      const typedArgs = args as SendEmailArgs;
      const { to, subject, text, html, from } = typedArgs;

      // Log tool call with arguments
      console.log("[Tool Call] send_email", {
        toolName: "send_email",
        arguments: {
          to,
          subject: `${subject.substring(0, 50)}${
            subject.length > 50 ? "..." : ""
          }`,
          text: `${text.substring(0, 100)}${text.length > 100 ? "..." : ""}`,
          hasHtml: !!html,
          from,
        },
        workspaceId,
      });

      try {
        const { sendEmailViaConnection } = await import("../../utils/email");
        await sendEmailViaConnection(workspaceId, {
          to: to.trim(),
          subject: subject.trim(),
          text: text.trim(),
          html: html?.trim(),
          from: from?.trim(),
        });

        const result = `✅ Email successfully sent to ${to}. The email has been delivered via the workspace's email connection.`;

        // Log tool result
        console.log("[Tool Result] send_email", {
          toolName: "send_email",
          result,
          to,
        });

        return result;
      } catch (error) {
        const errorMessage = `Error sending email: ${
          error instanceof Error ? error.message : String(error)
        }`;
        console.error("[Tool Error] send_email", {
          toolName: "send_email",
          error: error instanceof Error ? error.message : String(error),
          arguments: {
            to,
            subject: `${subject.substring(0, 50)}${
              subject.length > 50 ? "..." : ""
            }`,
          },
        });
        return errorMessage;
      }
    },
  });
}

/**
 * Internal function to call an agent with a message
 * Used for agent delegation
 */
async function callAgentInternal(
  workspaceId: string,
  targetAgentId: string,
  message: string,
  callDepth: number,
  maxDepth: number
): Promise<string> {
  // Check depth limit
  if (callDepth >= maxDepth) {
    return `Error: Maximum delegation depth (${maxDepth}) reached. Cannot delegate further.`;
  }

  const db = await database();

  // Validate and get target agent
  const targetAgentPk = `agents/${workspaceId}/${targetAgentId}`;
  const targetAgent = await db.agent.get(targetAgentPk, "agent");
  if (!targetAgent) {
    return `Error: Target agent ${targetAgentId} not found.`;
  }

  if (targetAgent.workspaceId !== workspaceId) {
    return `Error: Target agent ${targetAgentId} does not belong to this workspace.`;
  }

  // Get workspace API key if it exists (OpenRouter provider)
  const agentProvider: Provider = "openrouter";
  const workspaceApiKey = await getWorkspaceApiKey(workspaceId, agentProvider);
  const usesByok = workspaceApiKey !== null;

  // Use target agent's modelName if set, otherwise use default
  const modelName =
    typeof targetAgent.modelName === "string"
      ? targetAgent.modelName
      : undefined;

  // Create model
  const model = await createAgentModel(
    "http://localhost:3000/api/agent-delegation",
    workspaceApiKey || undefined,
    modelName,
    workspaceId,
    targetAgentId,
    usesByok,
    undefined, // userId
    agentProvider
  );

  // Extract agentId from targetAgent.pk (format: "agents/{workspaceId}/{agentId}")
  const extractedTargetAgentId = targetAgent.pk.replace(
    `agents/${workspaceId}/`,
    ""
  );

  // eslint-disable-next-line @typescript-eslint/no-explicit-any -- Tools have varying types
  const tools: Record<string, any> = {};

  // Add document search tool if enabled
  if (targetAgent.enableSearchDocuments === true) {
    const searchDocumentsTool = createSearchDocumentsTool(workspaceId, {
      messages: [{ role: "user", content: message }],
    });
    tools.search_documents = searchDocumentsTool;
  }

  // Add memory search tool if enabled
  if (targetAgent.enableMemorySearch === true) {
    const { createSearchMemoryTool } = await import("./memorySearchTool");
    tools.search_memory = createSearchMemoryTool(
      extractedTargetAgentId,
      workspaceId
    );
  }

  if (targetAgent.notificationChannelId) {
    tools.send_notification = createSendNotificationTool(
      workspaceId,
      targetAgent.notificationChannelId
    );
  }

  // Add email tool if enabled and workspace has email connection
  if (targetAgent.enableSendEmail === true) {
    const emailConnectionPk = `email-connections/${workspaceId}`;
    const emailConnection = await db["email-connection"].get(
      emailConnectionPk,
      "connection"
    );
    if (emailConnection) {
      tools.send_email = createSendEmailTool(workspaceId);
    }
  }

  // Add MCP server tools if target agent has enabled MCP servers
  if (
    targetAgent.enabledMcpServerIds &&
    Array.isArray(targetAgent.enabledMcpServerIds) &&
    targetAgent.enabledMcpServerIds.length > 0
  ) {
    const mcpTools = await createMcpServerTools(
      workspaceId,
      targetAgent.enabledMcpServerIds
    );
    // Merge MCP tools into tools object
    Object.assign(tools, mcpTools);
  }

  // Add client-side tools if target agent has client tools configured
  if (
    targetAgent.clientTools &&
    Array.isArray(targetAgent.clientTools) &&
    targetAgent.clientTools.length > 0
  ) {
    // Import createClientTools dynamically to avoid circular dependency
    const { createClientTools } = await import(
      "../post-api-workspaces-000workspaceId-agents-000agentId-test/utils/agentSetup"
    );
    const clientTools = createClientTools(targetAgent.clientTools);
    // Merge client tools into tools object
    Object.assign(tools, clientTools);
  }

  // Add delegation tools if target agent has delegatable agents
  if (
    targetAgent.delegatableAgentIds &&
    Array.isArray(targetAgent.delegatableAgentIds) &&
    targetAgent.delegatableAgentIds.length > 0
  ) {
    tools.list_agents = createListAgentsTool(
      workspaceId,
      targetAgent.delegatableAgentIds
    );
    tools.call_agent = createCallAgentTool(
      workspaceId,
      targetAgent.delegatableAgentIds,
      targetAgentId,
      callDepth + 1,
      maxDepth
    );
  }

  // Convert message to ModelMessage format
  const modelMessages: ModelMessage[] = [
    {
      role: "user",
      content: message,
    },
  ];

  let reservationId: string | undefined;
  let llmCallAttempted = false;
  let result: Awaited<ReturnType<typeof generateText>> | undefined;
  let tokenUsage: ReturnType<typeof extractTokenUsage> | undefined;

  try {
    // Reserve credits before LLM call
    const toolDefinitions =
      Object.keys(tools).length > 0
        ? Object.entries(tools).map(([name, tool]) => ({
            name,
            description: (tool as { description?: string }).description || "",
            parameters: (tool as { inputSchema?: unknown }).inputSchema || {},
          }))
        : undefined;

    const reservation = await validateCreditsAndLimitsAndReserve(
      db,
      workspaceId,
      targetAgentId,
      agentProvider, // provider
      modelName || MODEL_NAME,
      modelMessages,
      targetAgent.systemPrompt,
      toolDefinitions,
      false // usesByok - delegated calls use workspace API key if available
    );

    if (reservation) {
      reservationId = reservation.reservationId;
      console.log("[Agent Delegation] Credits reserved:", {
        workspaceId,
        targetAgentId,
        reservationId,
        reservedAmount: reservation.reservedAmount,
      });
    }

    // Generate response
    const generateOptions = buildGenerateTextOptions(targetAgent);
    console.log("[Agent Delegation] Executing generateText with parameters:", {
      workspaceId,
      targetAgentId,
      model: MODEL_NAME,
      systemPromptLength: targetAgent.systemPrompt.length,
      messagesCount: modelMessages.length,
      toolsCount: tools ? Object.keys(tools).length : 0,
      ...generateOptions,
    });
    // Log tool definitions before LLM call
    if (tools) {
      const { logToolDefinitions } = await import(
        "../post-api-workspaces-000workspaceId-agents-000agentId-test/utils/agentSetup"
      );
      logToolDefinitions(tools, "Agent Delegation", targetAgent);
    }
    result = await generateText({
      model: model as unknown as Parameters<typeof generateText>[0]["model"],
      system: targetAgent.systemPrompt,
      messages: modelMessages,
      tools,
      ...generateOptions,
    });
    // LLM call succeeded - mark as attempted
    llmCallAttempted = true;

    // Extract and track token usage for credit adjustment
    tokenUsage = extractTokenUsage(result);
    if (
      isCreditDeductionEnabled() &&
      reservationId &&
      reservationId !== "byok" &&
      tokenUsage &&
      (tokenUsage.promptTokens > 0 || tokenUsage.completionTokens > 0)
    ) {
      try {
        await adjustCreditReservation(
          db,
          reservationId,
          workspaceId,
          agentProvider, // provider
          modelName || MODEL_NAME,
          tokenUsage,
          3, // maxRetries
          false // usesByok - delegated calls use workspace API key if available
        );
        console.log(
          "[Agent Delegation] Credit reservation adjusted successfully"
        );
      } catch (error) {
        // Log error but don't fail the delegation call
        console.error(
          "[callAgentInternal] Error adjusting credit reservation:",
          {
            error: error instanceof Error ? error.message : String(error),
            workspaceId,
            targetAgentId,
            reservationId,
            tokenUsage,
          }
        );
      }
    } else if (
      reservationId &&
      reservationId !== "byok" &&
      (!tokenUsage ||
        (tokenUsage.promptTokens === 0 && tokenUsage.completionTokens === 0))
    ) {
      // No token usage after successful call - keep estimated cost (delete reservation)
      // This keeps the estimated cost deducted, which is correct since we can't determine actual cost
      console.warn(
        "[callAgentInternal] No token usage available after successful call, keeping estimated cost:",
        {
          workspaceId,
          targetAgentId,
          reservationId,
        }
      );
      // Delete reservation without refund (estimated cost remains deducted)
      try {
        const reservationPk = `credit-reservations/${reservationId}`;
        await db["credit-reservations"].delete(reservationPk);
      } catch (deleteError) {
        console.warn(
          "[callAgentInternal] Error deleting reservation:",
          deleteError
        );
      }
    }

    if (!result) {
      throw new Error("LLM call succeeded but result is undefined");
    }

    return result.text;
  } catch (error) {
    // Handle errors based on when they occurred
    if (reservationId && reservationId !== "byok") {
      if (!llmCallAttempted) {
        // Error before LLM call - refund reservation
        try {
          console.log(
            "[callAgentInternal] Error before LLM call, refunding reservation:",
            {
              workspaceId,
              targetAgentId,
              reservationId,
              error: error instanceof Error ? error.message : String(error),
            }
          );
          await refundReservation(db, reservationId);
        } catch (refundError) {
          // Log but don't fail - refund is best effort
          console.error("[callAgentInternal] Error refunding reservation:", {
            reservationId,
            error:
              refundError instanceof Error
                ? refundError.message
                : String(refundError),
          });
        }
      } else {
        // Error after LLM call - try to get token usage from error if available
        // If model error without token usage, assume reserved credits were consumed
        let errorTokenUsage: ReturnType<typeof extractTokenUsage> | undefined;
        try {
          // Try to extract token usage from error if it has a result property
          if (
            error &&
            typeof error === "object" &&
            "result" in error &&
            error.result
          ) {
            errorTokenUsage = extractTokenUsage(error.result);
          }
        } catch {
          // Ignore extraction errors
        }

        if (
          isCreditDeductionEnabled() &&
          errorTokenUsage &&
          (errorTokenUsage.promptTokens > 0 ||
            errorTokenUsage.completionTokens > 0)
        ) {
          // We have token usage - adjust reservation
          try {
            await adjustCreditReservation(
              db,
              reservationId,
              workspaceId,
              agentProvider,
              modelName || MODEL_NAME,
              errorTokenUsage,
              3,
              false
            );
          } catch (adjustError) {
            console.error(
              "[callAgentInternal] Error adjusting reservation after error:",
              adjustError
            );
          }
        } else {
          // No token usage available - assume reserved credits were consumed
          console.warn(
            "[callAgentInternal] Model error without token usage, assuming reserved credits consumed:",
            {
              workspaceId,
              targetAgentId,
              reservationId,
              error: error instanceof Error ? error.message : String(error),
            }
          );
          // Delete reservation without refund
          try {
            const reservationPk = `credit-reservations/${reservationId}`;
            await db["credit-reservations"].delete(reservationPk);
          } catch (deleteError) {
            console.warn(
              "[callAgentInternal] Error deleting reservation:",
              deleteError
            );
          }
        }
      }
    }

    console.error(
      `[callAgentInternal] Error calling agent ${targetAgentId}:`,
      error
    );
    return `Error calling agent: ${
      error instanceof Error ? error.message : String(error)
    }`;
  }
}

/**
 * Create the list_agents tool for listing delegatable agents
 */
export function createListAgentsTool(
  workspaceId: string,
  delegatableAgentIds: string[]
) {
  const listAgentsParamsSchema = z.object({});

  const description =
    "List all agents in the workspace that this agent can delegate to. Returns the name and ID of each delegatable agent. IMPORTANT: You MUST call this tool FIRST before calling call_agent, as you need to know the exact agent IDs to delegate to. Do not attempt to call_agent without first listing the available agents.";

  return tool({
    description,
    parameters: listAgentsParamsSchema,
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment -- AI SDK tool function has type inference limitations when schema is extracted
    // @ts-ignore - The execute function signature doesn't match the expected type, but works at runtime

    execute: async () => {
      try {
        const db = await database();

        // Get all delegatable agents
        const agents = await Promise.all(
          delegatableAgentIds.map(async (agentId) => {
            const agentPk = `agents/${workspaceId}/${agentId}`;
            const agent = await db.agent.get(agentPk, "agent");
            return agent;
          })
        );

        // Filter out any null results (agents that don't exist)
        const validAgents = agents.filter(
          (agent): agent is NonNullable<typeof agent> => agent !== null
        );

        if (validAgents.length === 0) {
          return "No delegatable agents found.";
        }

        // Format agent list - only name and ID
        const agentList = validAgents
          .map((agent) => {
            const agentId = agent.pk.replace(`agents/${workspaceId}/`, "");
            return `- ${agent.name} (ID: ${agentId})`;
          })
          .join("\n");

        return `Available agents for delegation (${validAgents.length}):\n\n${agentList}`;
      } catch (error) {
        console.error("Error in list_agents tool:", error);
        return `Error listing agents: ${
          error instanceof Error ? error.message : String(error)
        }`;
      }
    },
  });
}

/**
 * Create the call_agent tool for delegating to another agent
 */
export function createCallAgentTool(
  workspaceId: string,
  delegatableAgentIds: string[],
  currentAgentId: string,
  callDepth: number,
  maxDepth: number = 3
) {
  const callAgentParamsSchema = z.object({
    agentId: z
      .string()
      .min(1, "agentId parameter is required")
      .optional()
      .describe(
        "The exact agent ID to delegate to. You MUST call list_agents FIRST to get the available agent IDs. Do not guess or make up agent IDs - you must use the exact ID returned by list_agents."
      ),
    agent_id: z
      .string()
      .min(1, "agent_id parameter is required")
      .optional()
      .describe(
        "The exact agent ID to delegate to (alternative to agentId). You MUST call list_agents FIRST to get the available agent IDs. Do not guess or make up agent IDs - you must use the exact ID returned by list_agents."
      ),
    message: z
      .string()
      .min(1, "message parameter is required")
      .describe(
        "The message or query to send to the delegated agent. This should be the specific task or question you want the other agent to handle."
      ),
  });

  type CallAgentArgs = z.infer<typeof callAgentParamsSchema>;

  const description =
    "Delegate a task to another agent in the workspace. CRITICAL REQUIREMENTS: (1) You MUST call list_agents FIRST to see which agents are available and get their exact IDs. (2) Do NOT call this tool without first calling list_agents - you cannot guess agent IDs. (3) Provide the exact agent ID from the list_agents output and the message/query you want to send. (4) The delegated agent will process the request and return a response. You can only delegate to agents that have been configured as delegatable. Example workflow: First call list_agents to see available agents, then use one of the returned agent IDs to call this tool.";

  return tool({
    description,
    parameters: callAgentParamsSchema,
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment -- AI SDK tool function has type inference limitations when schema is extracted
    // @ts-ignore - The execute function signature doesn't match the expected type, but works at runtime
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    execute: async (args: any) => {
      const typedArgs = args as CallAgentArgs;
      // Normalize: accept both agentId and agent_id, prefer agentId
      const agentId = typedArgs.agentId || typedArgs.agent_id;
      const { message } = typedArgs;

      // Log tool call with arguments
      console.log("[Tool Call] call_agent", {
        toolName: "call_agent",
        arguments: {
          ...typedArgs,
          agentId, // Normalized agentId (from either agentId or agent_id)
          message: message
            ? `${message.substring(0, 100)}${message.length > 100 ? "..." : ""}`
            : undefined,
        },
        workspaceId,
        currentAgentId,
        callDepth,
        maxDepth,
      });

      // Validate agentId is a string
      if (!agentId || typeof agentId !== "string") {
        const errorMessage =
          agentId === undefined || agentId === null
            ? "Error: This tool call requires you to pass either the agentId or agent_id parameter, which you can get by listing the agents using the list_agents tool. Please call list_agents first to see available agents and their IDs, then use one of those IDs in the call_agent tool."
            : `Error: The agentId/agent_id parameter must be a non-empty string. Received: ${
                typeof agentId === "object"
                  ? JSON.stringify(agentId)
                  : String(agentId)
              }. Use list_agents to see available agents and their IDs.`;
        console.error("[Tool Error] call_agent", {
          toolName: "call_agent",
          error:
            agentId === undefined || agentId === null
              ? "Missing agentId"
              : "Invalid agentId type",
          arguments: {
            agentId,
            message: message
              ? `${message.substring(0, 100)}${
                  message.length > 100 ? "..." : ""
                }`
              : undefined,
          },
        });
        return errorMessage;
      }

      // Validate agentId is in the allowed list
      if (!delegatableAgentIds.includes(agentId)) {
        const errorMessage = `Error: Agent ID "${agentId}" is not in the list of delegatable agents. You must call list_agents FIRST to see which agents are available and get their exact IDs. Do not guess agent IDs - always call list_agents before calling call_agent.`;
        console.error("[Tool Error] call_agent", {
          toolName: "call_agent",
          error: "Agent not in delegatable list",
          arguments: {
            agentId,
            message: message
              ? `${message.substring(0, 100)}${
                  message.length > 100 ? "..." : ""
                }`
              : undefined,
          },
        });
        return errorMessage;
      }

      // Validate message
      if (
        !message ||
        typeof message !== "string" ||
        message.trim().length === 0
      ) {
        const errorMessage =
          "Error: The message parameter is required and must be a non-empty string.";
        console.error("[Tool Error] call_agent", {
          toolName: "call_agent",
          error: "Empty message",
          arguments: { agentId, message },
        });
        return errorMessage;
      }

      try {
        // Get target agent name for response formatting
        const db = await database();
        const targetAgentPk = `agents/${workspaceId}/${agentId}`;
        const targetAgent = await db.agent.get(targetAgentPk, "agent");

        if (!targetAgent) {
          const errorMessage = `Error: Target agent ${agentId} not found.`;
          console.error("[Tool Error] call_agent", {
            toolName: "call_agent",
            error: "Target agent not found",
            arguments: {
              agentId,
              message: `${message.substring(0, 100)}${
                message.length > 100 ? "..." : ""
              }`,
            },
          });
          return errorMessage;
        }

        const targetAgentName = targetAgent.name;

        // Call the agent internally
        const response = await callAgentInternal(
          workspaceId,
          agentId,
          message.trim(),
          callDepth,
          maxDepth
        );

        // Wrap response with metadata
        const result = `Agent ${targetAgentName} responded: ${response}`;

        // Log tool result
        console.log("[Tool Result] call_agent", {
          toolName: "call_agent",
          result:
            result.length > 500 ? `${result.substring(0, 500)}...` : result,
          resultLength: result.length,
          targetAgentId: agentId,
          targetAgentName,
        });

        return result;
      } catch (error) {
        const errorMessage = `Error calling agent: ${
          error instanceof Error ? error.message : String(error)
        }`;
        console.error("[Tool Error] call_agent", {
          toolName: "call_agent",
          error: error instanceof Error ? error.message : String(error),
          arguments: {
            agentId,
            message: message
              ? `${message.substring(0, 100)}${
                  message.length > 100 ? "..." : ""
                }`
              : undefined,
          },
        });
        return errorMessage;
      }
    },
  });
}
