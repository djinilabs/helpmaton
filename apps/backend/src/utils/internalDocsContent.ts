/**
 * Generated by scripts/generate-internal-docs.mjs — do not edit by hand.
 * Content only; loaded lazily when read_internal_doc is used.
 */

export const INTERNAL_DOCS_CONTENT: Record<string, string> = {
  "getting-started": "# Getting Started with Helpmaton\n\nWelcome to Helpmaton! This guide will help you get started with using the platform.\n\n## What is Helpmaton?\n\nHelpmaton is a workspace-based platform for managing AI agents and their interactions. You can create workspaces, add agents, and configure them to handle various tasks.\n\n## Quick Start\n\n1. **Create a Workspace**\n\n   - Click on \"Create Workspace\" from the main dashboard\n   - Give your workspace a name and optional description\n   - Workspaces help you organize your agents and documents\n\n2. **Add an Agent**\n\n   - Navigate to your workspace\n   - Click \"CREATE AGENT\"\n   - Provide a name and system prompt for your agent\n   - The system prompt defines how your agent behaves\n\n3. **Upload Documents**\n\n   - Use the document upload area to add markdown or text files\n   - Organize documents into folders for better management\n   - Documents can be used to inform agent behavior\n\n4. **Test Your Agent**\n   - Use the agent's webhook endpoint to send messages\n   - Monitor responses and adjust system prompts as needed\n\n## Next Steps\n\n- Read the [Agent Configuration Guide](./agent-configuration.md) for detailed agent setup\n- Check out [Document Management](./document-management.md) for organizing your files\n- Review [Workspace Permissions](./workspace-permissions.md) for team collaboration\n",
  "agent-configuration": "# Agent Configuration Guide\n\nThis guide covers how to configure and manage agents in Helpmaton.\n\n## Creating an Agent\n\nWhen creating a new agent, you'll need to provide:\n\n- **Name**: A descriptive name for your agent\n- **System Prompt**: Instructions that define how the agent behaves and responds\n\n## System Prompts\n\nThe system prompt is crucial for agent behavior. It should include:\n\n- The agent's role and purpose\n- Guidelines for how to respond\n- Any constraints or limitations\n- Context about the workspace or domain\n\n### Example System Prompt\n\n```\nYou are a helpful customer support agent for a software company.\nYour role is to:\n- Answer customer questions politely and professionally\n- Escalate technical issues to the engineering team\n- Provide clear, concise responses\n- Always maintain a friendly tone\n\nIf you don't know the answer, acknowledge it and offer to find out more information.\n```\n\n## Webhooks\n\nEach agent has one or more webhooks that can be used to send messages:\n\n- Webhooks are created automatically when you generate a key\n- Each webhook has a unique key that should be kept secure\n- Webhooks can be deleted if compromised\n- Use webhook URLs to send messages to agents\n\n## Testing Agents\n\nYou can test your agents using:\n\n- The test endpoint: `/api/streams/{workspaceId}/{agentId}/test`\n- Webhook endpoints: `/api/webhook/{workspaceId}/{agentId}/{key}`\n\n## Stream Servers\n\nStream servers enable real-time streaming responses from your agent using Lambda Function URLs. This provides lower latency and better user experience compared to non-streaming webhooks.\n\n### Configuration\n\nTo configure a stream server for an agent:\n\n1. Navigate to the agent's detail page\n2. Go to the \"Stream Servers\" section\n3. Configure allowed CORS origins (or use `[\"*\"]` for all origins)\n4. Save the configuration to receive a secret\n\n### Protocol\n\nStream servers use **Server-Sent Events (SSE)** format compatible with the [AI SDK](https://sdk.vercel.ai/docs):\n\n- **Text chunks**: `data: {\"type\":\"text-delta\",\"textDelta\":\"Hello\"}\\n\\n`\n- **Tool calls**: `data: {\"type\":\"tool-call\",\"toolCallId\":\"...\",\"toolName\":\"...\",\"args\":{...}}\\n\\n`\n\nThe stream is delivered over `text/event-stream` content type using standard SSE format.\n\n### Integration\n\nFor React applications, use the `useChat` hook from `@ai-sdk/react`:\n\n```typescript\nimport { useChat } from '@ai-sdk/react';\n\nconst { messages, append } = useChat({\n  api: `${streamUrl}/api/streams/${workspaceId}/${agentId}/${secret}`,\n});\n```\n\nFor complete protocol documentation, examples, and integration guides, see the [Streaming System documentation](./streaming-system.md).\n\n## Available Tools\n\nAgents can be configured with various tools to extend their capabilities:\n\n### Document Search\n\nEnable the `search_documents` tool to allow agents to search workspace documents using semantic vector search.\n\n### Memory Search\n\nEnable the `search_memory` tool to allow agents to recall past conversations and information from their memory system.\n\n## Inject Knowledge\n\nInject Knowledge lets you automatically add relevant context to user prompts at the beginning of a conversation. It combines:\n\n- **Workspace documents** (vector search over document snippets)\n- **Agent memories** (vector search over working memory + graph facts)\n- **Graph facts** (subject–predicate–object tuples stored for the agent)\n\n### Configuration\n\nIn the Agent Detail page, enable **Inject Knowledge** and configure:\n\n- **Inject from memories**: Pulls working memory snippets and graph facts.\n- **Entity extractor model**: Model used to extract entities from the user’s prompt before graph search. If empty, the default model is used.\n- **Inject from documents**: Includes workspace document snippets in the injected knowledge.\n- **Snippet count**: Total number of snippets to inject after merging and re-ranking (1–50).\n- **Minimum similarity**: Filter threshold for snippet relevance.\n- **Re-ranking** (optional): Re-rank all retrieved snippets (documents + memories + graph facts) using a rerank model.\n\nIf both **memories** and **documents** are disabled while Inject Knowledge is enabled, the settings are invalid and won’t save.\n\n### How it works\n\n1. Extract the query from the first user message.\n2. If **Inject from documents** is on, search workspace documents via vector similarity.\n3. If **Inject from memories** is on:\n   - Search working memory via vector similarity.\n   - Extract entities from the prompt, then fetch matching graph facts.\n4. Merge all snippets, optionally re-rank, then inject the top results as a new user message before the first user prompt.\n\n### Email Sending\n\nEnable the `send_email` tool to allow agents to send emails using the workspace email connection (requires email connection configuration).\n\n### Web Tools\n\nEnable web tools to allow agents to search the web and extract content from URLs:\n\n- **Web Search** (`search_web`): Search the web for current information, news, articles, and other web content. Available providers:\n  - **Tavily**: $0.008 per call (first 10 calls/day free for paid tiers)\n  - **Jina.ai**: Free (no credits charged, rate limits may apply)\n- **Web Fetch** (`fetch_url`): Extract and summarize content from specific web page URLs. Available providers:\n  - **Tavily**: $0.008 per call (first 10 calls/day free for paid tiers)\n  - **Jina.ai**: Free (no credits charged, rate limits may apply)\n\n**Daily Limits (Tavily only)**:\n- Free tier: 10 calls per 24 hours\n- Paid tiers: 10 free calls/day, then $0.008 per call (requires workspace credits)\n\n**Note**: Jina.ai is free to use but may have rate limits. Tavily requires credits after the free tier limit.\n\n### Exa.ai Search\n\nEnable the `search` tool to allow agents to perform category-specific searches using Exa.ai:\n\n- **Tool Name**: `search` (separate from `search_web`)\n- **Categories**: Supports 9 search categories:\n  - `company` - Search for company information\n  - `research paper` - Search for academic research papers\n  - `news` - Search for news articles\n  - `pdf` - Search for PDF documents\n  - `github` - Search for GitHub repositories\n  - `tweet` - Search for tweets\n  - `personal site` - Search personal websites\n  - `people` - Search for people\n  - `financial report` - Search for financial reports\n- **Parameters**:\n  - `category` (required): One of the 9 supported categories\n  - `query` (required): Search query string\n  - `num_results` (optional): Number of results to return (1-100, default: 10)\n- **Pricing**: Variable based on number of results:\n  - 1-25 results: $5 per 1,000 requests\n  - 26-100 results: $25 per 1,000 requests\n- **Note**: Pay-as-you-go pricing - all requests require credits (no free tier)\n\nSee [Tavily Integration](./tavily-integration.md) for detailed documentation.\n\n### MCP Server Tools\n\nEnable MCP (Model Context Protocol) servers to expose their tools to agents. Each enabled MCP server provides tools based on its configuration.\n\n### Agent Delegation\n\nConfigure `delegatableAgentIds` to allow agents to delegate tasks to other agents in the workspace.\n\n### Client-Side Tools\n\nDefine custom client-side tools that execute in the client application rather than on the server.\n\n## Best Practices\n\n1. **Clear Prompts**: Write specific, actionable system prompts\n2. **Iterate**: Test and refine prompts based on agent responses\n3. **Document Context**: Upload relevant documents to inform agent behavior\n4. **Security**: Keep webhook keys secure and rotate them regularly\n5. **Tool Selection**: Enable only the tools your agent needs to minimize costs and complexity\n\n",
  "document-management": "# Document Management\n\nHelpmaton allows you to upload, organize, and manage documents that can inform your agents' behavior.\n\n## Supported File Types\n\n- Markdown files (`.md`, `.markdown`)\n- Plain text files (`.txt`)\n\nMaximum file size: 10MB per file\n\n## Uploading Documents\n\n### Method 1: Drag and Drop\n\n1. Navigate to your workspace\n2. Find the document upload area\n3. Drag files from your computer into the upload zone\n4. Select a destination folder (optional)\n\n### Method 2: File Selection\n\n1. Click \"SELECT FILES\" in the upload area\n2. Choose one or more files from your computer\n3. Select a destination folder (optional)\n\n### Method 3: Create from Text\n\n1. Use the \"CREATE TEXT DOCUMENT\" section\n2. Enter a document name\n3. Type or paste your content\n4. Click \"CREATE DOCUMENT\"\n\n## Organizing Documents\n\n### Folders\n\nDocuments can be organized into folders:\n\n- Create folders by typing a new folder name when uploading\n- Select existing folders from the dropdown\n- Navigate folders using breadcrumbs\n- Documents are stored in S3 with folder structure preserved\n\n### Folder Structure\n\nFolders can be nested using forward slashes:\n\n- `docs/getting-started` creates a nested structure\n- Empty folder name represents the root folder\n\n## Managing Documents\n\n### Viewing and Editing\n\n1. Click on any document name to open the viewer\n2. Edit the document name, content, or folder location\n3. Save changes to update the document\n\n### Renaming Documents\n\n- Click on a document to open the viewer\n- Edit the name field\n- Save to rename the file in S3\n\n### Moving Documents\n\n- Open the document viewer\n- Select a different folder from the dropdown\n- Save to move the document\n\n### Deleting Documents\n\n- Open the document viewer\n- Click the \"DELETE\" button\n- Confirm deletion\n\n## Best Practices\n\n1. **Organize Early**: Set up folder structure before uploading many documents\n2. **Descriptive Names**: Use clear, descriptive document names\n3. **Regular Updates**: Keep documents current and relevant\n4. **Version Control**: Consider keeping important versions of documents\n",
  "workspace-permissions": "# Workspace Permissions\n\nHelpmaton uses a permission-based system to control access to workspaces and their resources.\n\n## Permission Levels\n\nThere are three permission levels:\n\n### READ (Level 1)\n- View workspace details\n- View agents and their configurations\n- View documents\n- Cannot make changes\n\n### WRITE (Level 2)\n- All READ permissions\n- Create and edit agents\n- Upload, edit, and delete documents\n- Modify workspace settings\n- Cannot delete the workspace\n\n### OWNER (Level 3)\n- All WRITE permissions\n- Delete the workspace\n- Manage workspace members and permissions\n- Full administrative control\n\n## Managing Permissions\n\n### As a Workspace Owner\n\n1. Navigate to your workspace\n2. Access the members/permissions section\n3. Add users and assign permission levels\n4. Modify or remove user permissions as needed\n\n### Permission Inheritance\n\n- Permissions apply to the entire workspace\n- All agents and documents inherit workspace permissions\n- Individual resource-level permissions may be added in the future\n\n## Security Best Practices\n\n1. **Principle of Least Privilege**: Grant minimum necessary permissions\n2. **Regular Audits**: Review workspace members periodically\n3. **Key Management**: Keep webhook keys secure\n4. **Document Access**: Be mindful of sensitive information in documents\n\n## Common Scenarios\n\n### Team Collaboration\n- Grant WRITE access to team members who need to create content\n- Use READ access for stakeholders who only need to view\n\n### External Sharing\n- Use READ access for external partners\n- Consider creating separate workspaces for sensitive projects\n\n### Administrative Access\n- Only workspace owners can delete workspaces\n- Owners should be trusted team members\n\n",
  "api-reference": "# API Reference\n\nThis document provides comprehensive documentation for all Helpmaton API endpoints, including request/response formats, authentication requirements, and error codes.\n\n## Base URL\n\n- **Production**: `https://app.helpmaton.com`\n- **Local Development**: `http://localhost:5173` (frontend proxy) or `http://localhost:3333` (direct backend)\n\n## Bot Integrations\n\nBot integrations allow you to connect your agents to Slack or Discord bots. See [Slack Integration Guide](./slack-integration.md) and [Discord Integration Guide](./discord-integration.md) for setup instructions.\n\n### List Integrations\n\n**Endpoint**: `GET /api/workspaces/:workspaceId/integrations`\n\n**Authentication**: Required (Bearer token or session cookie)\n\n**Response**:\n```json\n[\n  {\n    \"id\": \"integration-id\",\n    \"platform\": \"slack\",\n    \"name\": \"Support Bot\",\n    \"agentId\": \"agent-id\",\n    \"webhookUrl\": \"https://app.helpmaton.com/api/webhooks/slack/workspace-id/integration-id\",\n    \"status\": \"active\",\n    \"lastUsedAt\": \"2024-01-01T00:00:00.000Z\",\n    \"createdAt\": \"2024-01-01T00:00:00.000Z\"\n  }\n]\n```\n\n### Create Integration\n\n**Endpoint**: `POST /api/workspaces/:workspaceId/integrations`\n\n**Authentication**: Required (Bearer token or session cookie, WRITE permission)\n\n**Request Body**:\n```json\n{\n  \"platform\": \"slack\",\n  \"name\": \"Support Bot\",\n  \"agentId\": \"agent-id\",\n  \"config\": {\n    \"botToken\": \"xoxb-...\",\n    \"signingSecret\": \"...\"\n  }\n}\n```\n\n**Response**: Returns the created integration (same format as list)\n\n### Get Integration\n\n**Endpoint**: `GET /api/workspaces/:workspaceId/integrations/:integrationId`\n\n**Authentication**: Required (Bearer token or session cookie)\n\n### Update Integration\n\n**Endpoint**: `PATCH /api/workspaces/:workspaceId/integrations/:integrationId`\n\n**Authentication**: Required (Bearer token or session cookie, WRITE permission)\n\n**Request Body**:\n```json\n{\n  \"name\": \"Updated Name\",\n  \"status\": \"inactive\",\n  \"config\": {\n    \"botToken\": \"new-token\"\n  }\n}\n```\n\n### Delete Integration\n\n**Endpoint**: `DELETE /api/workspaces/:workspaceId/integrations/:integrationId`\n\n**Authentication**: Required (Bearer token or session cookie, WRITE permission)\n\n### Generate Slack Manifest\n\n**Endpoint**: `POST /api/workspaces/:workspaceId/integrations/slack/manifest`\n\n**Authentication**: Required (Bearer token or session cookie, WRITE permission)\n\n**Request Body**:\n```json\n{\n  \"agentId\": \"agent-id\",\n  \"agentName\": \"Support Bot\"\n}\n```\n\n**Response**:\n```json\n{\n  \"manifest\": { ... },\n  \"webhookUrl\": \"https://app.helpmaton.com/api/webhooks/slack/workspace-id/integration-id\",\n  \"instructions\": [ ... ]\n}\n```\n\n## Authentication\n\nHelpmaton supports multiple authentication methods:\n\n### Session Cookies (Web UI)\n\nFor browser-based requests, use session cookies:\n\n```bash\n# Cookies are automatically sent with requests\ncurl -b cookies.txt https://app.helpmaton.com/api/workspaces\n```\n\n### Bearer Token (API)\n\nFor programmatic access, use JWT access tokens:\n\n```bash\ncurl -H \"Authorization: Bearer eyJhbGciOiJIUzI1NiIs...\" \\\n  https://app.helpmaton.com/api/workspaces\n```\n\n### API Keys\n\nUser API keys can also be used as Bearer tokens:\n\n```bash\ncurl -H \"Authorization: Bearer hmat_abc123def456...\" \\\n  https://app.helpmaton.com/api/workspaces\n```\n\nSee [Authentication](./authentication.md) for detailed authentication documentation.\n\n## Workspaces\n\n### List Workspaces\n\n**Endpoint**: `GET /api/workspaces`\n\n**Authentication**: Required (Bearer token or session cookie)\n\n**Description**: Returns all workspaces the authenticated user has access to.\n\n**Response** (200 OK):\n\n```json\n[\n  {\n    \"id\": \"ws_123\",\n    \"name\": \"My Workspace\",\n    \"description\": \"Workspace description\",\n    \"creditBalance\": 10.5,\n    \"currency\": \"usd\",\n    \"subscriptionId\": \"sub_123\",\n    \"createdAt\": \"2024-01-01T00:00:00Z\",\n    \"updatedAt\": \"2024-01-01T00:00:00Z\"\n  }\n]\n```\n\n### Get Workspace\n\n**Endpoint**: `GET /api/workspaces/:workspaceId`\n\n**Authentication**: Required (Bearer token or session cookie)\n\n**Description**: Returns details for a specific workspace.\n\n**Path Parameters**:\n\n- `workspaceId` (String, required): Workspace ID\n\n**Response** (200 OK):\n\n```json\n{\n  \"id\": \"ws_123\",\n  \"name\": \"My Workspace\",\n  \"description\": \"Workspace description\",\n  \"creditBalance\": 10.5,\n  \"currency\": \"usd\",\n  \"subscriptionId\": \"sub_123\",\n  \"spendingLimits\": [\n    {\n      \"timeFrame\": \"daily\",\n      \"amount\": 5.0\n    }\n  ],\n  \"createdAt\": \"2024-01-01T00:00:00Z\",\n  \"updatedAt\": \"2024-01-01T00:00:00Z\"\n}\n```\n\n**Errors**:\n\n- `401 Unauthorized`: Not authenticated\n- `403 Forbidden`: No access to workspace\n- `404 Not Found`: Workspace not found\n\n### Create Workspace\n\n**Endpoint**: `POST /api/workspaces`\n\n**Authentication**: Required (Bearer token or session cookie)\n\n**Description**: Creates a new workspace.\n\n**Request Body**:\n\n```json\n{\n  \"name\": \"My Workspace\",\n  \"description\": \"Optional description\"\n}\n```\n\n**Response** (201 Created):\n\n```json\n{\n  \"id\": \"ws_123\",\n  \"name\": \"My Workspace\",\n  \"description\": \"Optional description\",\n  \"creditBalance\": 0,\n  \"currency\": \"usd\",\n  \"subscriptionId\": \"sub_123\",\n  \"createdAt\": \"2024-01-01T00:00:00Z\",\n  \"updatedAt\": \"2024-01-01T00:00:00Z\"\n}\n```\n\n**Errors**:\n\n- `400 Bad Request`: Invalid request body\n- `401 Unauthorized`: Not authenticated\n- `402 Payment Required`: Subscription limit exceeded\n\n### Update Workspace\n\n**Endpoint**: `PUT /api/workspaces/:workspaceId`\n\n**Authentication**: Required (Bearer token or session cookie)\n\n**Permission**: WRITE or higher\n\n**Description**: Updates workspace details.\n\n**Path Parameters**:\n\n- `workspaceId` (String, required): Workspace ID\n\n**Request Body**:\n\n```json\n{\n  \"name\": \"Updated Name\",\n  \"description\": \"Updated description\"\n}\n```\n\n**Response** (200 OK):\n\n```json\n{\n  \"id\": \"ws_123\",\n  \"name\": \"Updated Name\",\n  \"description\": \"Updated description\",\n  \"creditBalance\": 10.5,\n  \"currency\": \"usd\",\n  \"subscriptionId\": \"sub_123\",\n  \"createdAt\": \"2024-01-01T00:00:00Z\",\n  \"updatedAt\": \"2024-01-01T01:00:00Z\"\n}\n```\n\n**Errors**:\n\n- `400 Bad Request`: Invalid request body\n- `401 Unauthorized`: Not authenticated\n- `403 Forbidden`: Insufficient permissions\n- `404 Not Found`: Workspace not found\n\n### Delete Workspace\n\n**Endpoint**: `DELETE /api/workspaces/:workspaceId`\n\n**Authentication**: Required (Bearer token or session cookie)\n\n**Permission**: OWNER\n\n**Description**: Deletes a workspace and all its resources.\n\n**Path Parameters**:\n\n- `workspaceId` (String, required): Workspace ID\n\n**Response** (204 No Content)\n\n**Errors**:\n\n- `401 Unauthorized`: Not authenticated\n- `403 Forbidden`: Insufficient permissions (OWNER required)\n- `404 Not Found`: Workspace not found\n\n## Agents\n\n### List Agents\n\n```\nGET /api/workspaces/:workspaceId/agents\n```\n\nReturns all agents in a workspace.\n\n### Get Agent\n\n```\nGET /api/workspaces/:workspaceId/agents/:agentId\n```\n\nReturns details for a specific agent.\n\n### Create Agent\n\n```\nPOST /api/workspaces/:workspaceId/agents\nBody: { name: string, systemPrompt: string }\n```\n\nCreates a new agent.\n\n### Update Agent\n\n```\nPUT /api/workspaces/:workspaceId/agents/:agentId\nBody: { name?: string, systemPrompt?: string }\n```\n\nUpdates agent configuration.\n\n### Delete Agent\n\n```\nDELETE /api/workspaces/:workspaceId/agents/:agentId\n```\n\nDeletes an agent.\n\n## Webhooks\n\n### Agent keys (webhook keys)\n\nManage per-agent webhook keys used to authenticate requests to the agent webhook and widget endpoints.\n\n**List webhooks**: `GET /api/workspaces/:workspaceId/agents/:agentId/keys` — Returns all webhook keys for an agent.\n\n**Create webhook**: `POST /api/workspaces/:workspaceId/agents/:agentId/keys` — Body: `{ name?: string }`. Creates a new webhook key; the key value is returned only once.\n\n**Delete webhook**: `DELETE /api/workspaces/:workspaceId/agents/:agentId/keys/:keyId` — Deletes a webhook key.\n\n### Agent webhook endpoint\n\n```\nPOST /api/webhook/:workspaceId/:agentId/:key\n```\n\nSends a message to an agent and receives a streaming response. Authenticated by the agent key in the path.\n\n### Streaming and test endpoints\n\nStreaming uses the same base URL as the app (or the Lambda stream URL from `GET /api/stream-url`). All require `POST` with an AI SDK message array in the body.\n\n| Path | Auth | Use |\n|------|------|-----|\n| `POST /api/streams/:workspaceId/:agentId/:secret` | Secret (path) | Production streaming; secret from agent stream server config |\n| `POST /api/streams/:workspaceId/:agentId/test` | Session/JWT | Test a specific agent |\n| `POST /api/streams/:workspaceId/_workspace/test` | Session/JWT | Workspace assistant (virtual agent) |\n| `POST /api/streams/:workspaceId/:agentId/config/test` | Session/JWT | Meta-agent \"Configure with AI\" chat |\n\nSee [Streaming System](./streaming-system.md) and [Webhook System](./webhook-system.md) for details.\n\n## Documents\n\n### List Documents\n\n```\nGET /api/workspaces/:workspaceId/documents?folder=<folderPath>\n```\n\nReturns all documents in a workspace, optionally filtered by folder.\n\n### List Folders\n\n```\nGET /api/workspaces/:workspaceId/documents/folders\n```\n\nReturns all unique folder paths in a workspace.\n\n### Upload Documents\n\n```\nPOST /api/workspaces/:workspaceId/documents\nContent-Type: multipart/form-data\nBody: files (File[]), folderPath (string?), textDocuments (JSON?)\n```\n\nUploads one or more documents. Supports file uploads or text-based document creation.\n\n### Get Document\n\n```\nGET /api/workspaces/:workspaceId/documents/:documentId\n```\n\nReturns document content and metadata.\n\n### Update Document\n\n```\nPUT /api/workspaces/:workspaceId/documents/:documentId\nBody: { content?: string, name?: string, folderPath?: string }\n```\n\nUpdates document content, name, or location.\n\n### Rename Document\n\n```\nPATCH /api/workspaces/:workspaceId/documents/:documentId/rename\nBody: { name: string }\n```\n\nRenames a document (updates filename in S3).\n\n### Delete Document\n\n```\nDELETE /api/workspaces/:workspaceId/documents/:documentId\n```\n\nDeletes a document.\n\n## Error Responses\n\nAll endpoints return standard HTTP status codes with JSON error responses.\n\n### Status Codes\n\n- `200 OK` - Success\n- `201 Created` - Resource created successfully\n- `204 No Content` - Success with no response body\n- `400 Bad Request` - Invalid request format or parameters\n- `401 Unauthorized` - Authentication required or invalid\n- `402 Payment Required` - Insufficient credits or spending limit exceeded\n- `403 Forbidden` - Insufficient permissions or access denied\n- `404 Not Found` - Resource not found\n- `429 Too Many Requests` - Rate limit exceeded\n- `500 Internal Server Error` - Server error\n\n### Error Response Format\n\n```json\n{\n  \"error\": \"Error message\",\n  \"message\": \"Detailed error message\",\n  \"code\": \"ERROR_CODE\"\n}\n```\n\n### Common Error Codes\n\n**Authentication Errors**:\n\n- `UNAUTHORIZED`: Not authenticated or invalid token\n- `INVALID_TOKEN`: Token is invalid or expired\n- `INVALID_API_KEY`: API key is invalid\n\n**Permission Errors**:\n\n- `FORBIDDEN`: Insufficient permissions\n- `WORKSPACE_ACCESS_DENIED`: No access to workspace\n\n**Business Logic Errors**:\n\n- `INSUFFICIENT_CREDITS`: Credit balance insufficient\n- `SPENDING_LIMIT_EXCEEDED`: Spending limit exceeded\n- `SUBSCRIPTION_LIMIT_EXCEEDED`: Subscription limit exceeded\n- `FREE_PLAN_EXPIRED`: Free plan has expired\n\n**Validation Errors**:\n\n- `INVALID_REQUEST`: Request format is invalid\n- `MISSING_REQUIRED_FIELD`: Required field is missing\n- `INVALID_VALUE`: Field value is invalid\n\n### Rate Limiting\n\nWhen rate limits are exceeded, a `429 Too Many Requests` response is returned:\n\n```json\n{\n  \"error\": \"Too Many Requests\",\n  \"message\": \"Rate limit exceeded. Please try again later.\"\n}\n```\n\n**Headers**:\n\n- `Retry-After`: Seconds to wait before retrying\n- `X-RateLimit-Limit`: Maximum requests per period\n- `X-RateLimit-Remaining`: Remaining requests in period\n- `X-RateLimit-Reset`: Timestamp when limit resets\n\nSee [API Throttling](./api-throttling.md) for detailed rate limiting information.\n\n## Rate Limiting\n\nAll API endpoints are subject to rate limiting based on subscription plans:\n\n- **Free**: 100 requests/second, 200 burst\n- **Starter**: 500 requests/second, 1000 burst\n- **Pro**: 2000 requests/second, 4000 burst\n\nRate limits apply to all `/api/*` routes except `/api/auth/*` and `/api/authorizer`.\n\n## Additional Resources\n\n- [Webhook System](./webhook-system.md) - Webhook endpoint details\n- [Streaming System](./streaming-system.md) - Streaming endpoint details\n- [Authentication](./authentication.md) - Authentication methods\n- [Credit System](./credit-system.md) - Credit management\n- [Subscription Management](./subscription-management.md) - Subscription plans\n\nFor a complete list of endpoints (including workspace onboarding agent stream, improve-prompt-from-evals, export/import, credits purchase, trial, stream-servers, user API keys, and auth token endpoints), see the OpenAPI specification below.\n\n## OpenAPI Specification\n\nComplete OpenAPI 3.1 specification is available at:\n\n- `apps/backend/openapi.json`\n- `apps/frontend/public/openapi.json`\n\nYou can use this specification to:\n\n- Generate client libraries\n- Explore endpoints in Swagger UI\n- Validate requests/responses\n",
  "pricing": "# Pricing System\n\nThis document explains how Helpmaton calculates and charges for LLM API calls, including the integration with OpenRouter, model price management, cost calculation, and credit deduction system.\n\n## Overview\n\nHelpmaton uses a sophisticated 3-step pricing verification system that ensures accurate billing for LLM API calls. The system integrates with OpenRouter as the primary LLM provider, maintains up-to-date model pricing, and uses a credit reservation system to prevent over-spending.\n\n## OpenRouter Integration\n\nHelpmaton relies on [OpenRouter](https://openrouter.ai/) as the primary LLM provider. OpenRouter provides:\n\n- **Unified API**: Single API to access multiple LLM providers (OpenAI, Anthropic, Google, etc.)\n- **Cost Transparency**: Detailed cost information for each API call\n- **Generation Tracking**: Unique generation IDs for each API response to track costs\n\n### Why OpenRouter?\n\n1. **Multi-Provider Support**: Access to models from multiple providers through a single API\n2. **Cost Tracking**: OpenRouter provides detailed cost information via their API\n3. **Reliability**: OpenRouter handles provider failover and rate limiting\n4. **BYOK Support**: Workspaces can use their own OpenRouter API keys (Bring Your Own Key)\n\n### OpenRouter API Key\n\nHelpmaton uses a system-level OpenRouter API key (`OPENROUTER_API_KEY`) for:\n- Making LLM API calls on behalf of workspaces\n- Fetching model pricing information\n- Verifying costs for completed generations\n\n## Model Price Management\n\n### Recurrent Price Downloads\n\nModel prices are automatically downloaded and updated on a **daily schedule** via GitHub Actions:\n\n- **Schedule**: Runs daily at midnight UTC (`0 0 * * *`)\n- **Workflow**: `.github/workflows/update-pricing.yml`\n- **Script**: `scripts/update-pricing.mjs`\n\n### Price Update Process\n\nThe pricing update script performs the following steps:\n\n1. **Fetch OpenRouter Models**: Queries OpenRouter API (`https://openrouter.ai/api/v1/models`) to get all available models\n2. **Extract Pricing**: Extracts pricing information from each model's `pricing` object:\n   - `prompt` (input tokens per token, as string)\n   - `completion` (output tokens per token, as string)\n   - `prompt_cached` (cached input tokens per token, optional)\n   - `request` (fixed cost per request, optional)\n3. **Convert to Per-Million Format**: Converts per-token prices to per-1M-token prices (multiplies by 1,000,000)\n4. **Apply 5.5% Markup**: Applies a 5.5% markup to all OpenRouter prices to account for OpenRouter's credit purchase fee\n5. **Update Configuration**: Updates `apps/backend/src/config/pricing.json` with new pricing\n6. **Commit Changes**: Automatically commits and pushes changes to the repository\n\n### Pricing Configuration Format\n\nPricing is stored in `apps/backend/src/config/pricing.json`:\n\n```json\n{\n  \"providers\": {\n    \"openrouter\": {\n      \"models\": {\n        \"google/gemini-2.5-flash\": {\n          \"usd\": {\n            \"input\": 0.075,\n            \"output\": 0.3,\n            \"cachedInput\": 0.0075,\n            \"reasoning\": 3.5\n          }\n        }\n      }\n    }\n  },\n  \"lastUpdated\": \"2025-01-15T00:00:00.000Z\"\n}\n```\n\n### Model Exclusions\n\nCertain models are excluded from pricing updates:\n\n- **Exact matches**: `gemini-1.5-flash`, `gemini-1.5-pro`\n- **Pattern matches**: Models containing `-tts`, `tts-`, `-image`, `image-` (TTS and image generation models)\n\n### Manual Price Updates\n\nThe pricing update can also be triggered manually:\n\n```bash\npnpm update-pricing\n```\n\nThis requires:\n- `OPENROUTER_API_KEY` environment variable\n- `GEMINI_API_KEY` environment variable (for Google model pricing)\n\n## 3-Step Pricing Verification\n\nHelpmaton uses a 3-step pricing verification process to ensure accurate billing:\n\n### Step 1: Estimate and Reserve\n\n**When**: Before making the LLM API call\n\n**Process**:\n1. Estimate token usage based on message length, system prompt, and tool definitions\n2. Calculate estimated cost using current model pricing\n3. Atomically reserve credits from workspace balance\n4. Create a reservation record with 15-minute TTL\n\n**Code Location**: `apps/backend/src/utils/creditManagement.ts` - `reserveCredits()`\n\n**Key Features**:\n- Uses DynamoDB `atomicUpdate` to prevent race conditions\n- Validates credit balance before reservation\n- Creates reservation record for tracking\n- Skips reservation for BYOK requests\n\n### Step 2: Adjust Based on Token Usage\n\n**When**: Immediately after LLM API call completes\n\n**Process**:\n1. Extract actual token usage from API response:\n   - `promptTokens` (input)\n   - `completionTokens` (output)\n   - `reasoningTokens` (optional)\n   - `cachedPromptTokens` (optional)\n2. Calculate actual cost from token usage using model pricing\n3. Compare actual cost to reserved amount\n4. Adjust workspace balance:\n   - If actual > reserved: Deduct additional amount\n   - If actual < reserved: Refund difference\n5. Store token usage-based cost and OpenRouter generation ID in reservation record\n\n**Code Location**: `apps/backend/src/utils/creditManagement.ts` - `adjustCreditReservation()`\n\n**Key Features**:\n- Handles all token types (input, output, reasoning, cached)\n- Supports tiered pricing models\n- Applies 5.5% OpenRouter markup\n- Stores generation ID for final verification\n\n### Step 3: Finalize with OpenRouter Cost\n\n**When**: Background job (SQS queue) after OpenRouter API provides final cost\n\n**Process**:\n1. Queue processor receives OpenRouter generation ID\n2. Fetches actual cost from OpenRouter API (`https://openrouter.ai/api/v1/generation?id={generationId}`)\n3. Extracts `total_cost` from OpenRouter response\n4. Applies 5.5% markup to OpenRouter cost\n5. Compares OpenRouter cost to token usage-based cost (from Step 2)\n6. Makes final adjustment to workspace balance\n7. Updates conversation message with `finalCostUsd`\n8. Deletes reservation record\n\n**Code Location**: \n- Queue: `apps/backend/src/queues/openrouter-cost-verification-queue/index.ts`\n- Finalization: `apps/backend/src/utils/creditManagement.ts` - `finalizeCreditReservation()`\n\n**Key Features**:\n- Asynchronous processing via SQS FIFO queue\n- Handles missing generations gracefully\n- Updates conversation records with final costs\n- Ensures billing accuracy with OpenRouter's authoritative cost data\n\n### Why 3 Steps?\n\n1. **Step 1 (Estimate)**: Prevents over-spending by reserving credits upfront\n2. **Step 2 (Token Usage)**: Provides quick adjustment based on actual token counts\n3. **Step 3 (OpenRouter)**: Ensures final accuracy using OpenRouter's authoritative cost data\n\nThis approach balances:\n- **User Experience**: Quick response times (Steps 1-2 are synchronous)\n- **Accuracy**: Final verification ensures correct billing (Step 3 is asynchronous)\n- **Reliability**: Handles edge cases where token counts might not match OpenRouter's billing\n\n## Cost Calculation\n\n### Token Cost Formula\n\nCosts are calculated using the following formula:\n\n```typescript\n// All prices are per 1M tokens\ninputCost = (inputTokens / 1_000_000) × inputPrice\ncachedInputCost = (cachedTokens / 1_000_000) × cachedInputPrice\noutputCost = (outputTokens / 1_000_000) × outputPrice\nreasoningCost = (reasoningTokens / 1_000_000) × reasoningPrice\nrequestCost = requestPrice (fixed per request)\n\nbaseCost = inputCost + cachedInputCost + outputCost + reasoningCost + requestCost\n\n// Apply 5.5% markup for OpenRouter\nif (provider === \"openrouter\") {\n  totalCost = Math.ceil(baseCost × 1.055)\n} else {\n  totalCost = baseCost\n}\n```\n\n### Currency Representation\n\nAll costs are stored as **integer nano-dollars** to avoid floating-point precision issues:\n\n- `$0.001` = `1,000,000` nano-dollars\n- `$1.00` = `1,000,000,000` nano-dollars\n- `$0.000000001` = `1` nano-dollar\n\nThis ensures:\n- No precision loss in calculations\n- Accurate credit balance tracking\n- Consistent rounding (always rounds up using `Math.ceil()`)\n\n### Rounding Policy\n\n**All costs are rounded UP** using `Math.ceil()` to ensure Helpmaton never undercharges:\n\n```typescript\n// Example: $0.0001234 becomes $0.000124 (rounded up)\ncostInNanoDollars = Math.ceil(actualCost * 1_000_000_000)\n```\n\nThis policy applies to:\n- Step 1: Estimated costs\n- Step 2: Token usage-based costs\n- Step 3: OpenRouter costs\n\n### Tiered Pricing\n\nSome models use tiered pricing (different rates for different token count ranges):\n\n```json\n{\n  \"usd\": {\n    \"tiers\": [\n      {\n        \"threshold\": 200000,\n        \"input\": 1.25,\n        \"output\": 5.0\n      },\n      {\n        \"input\": 2.5,\n        \"output\": 10.0\n      }\n    ]\n  }\n}\n```\n\nThe system:\n1. Sorts tiers by threshold (ascending)\n2. Calculates cost for tokens in each tier range\n3. Sums costs across all tiers\n\nSee `docs/pricing-calculation.md` for detailed tiered pricing examples.\n\n### 5.5% OpenRouter Markup\n\nAll OpenRouter costs include a 5.5% markup to account for OpenRouter's credit purchase fee:\n\n```typescript\nif (provider === \"openrouter\") {\n  totalCost = Math.ceil(baseCost * 1.055)\n}\n```\n\nThis markup is applied:\n- In Step 1: Estimated costs\n- In Step 2: Token usage-based costs\n- In Step 3: OpenRouter API costs\n\n## Credit Reservation System\n\nThe credit reservation system ensures accurate billing and prevents over-spending.\n\n### Reservation Lifecycle\n\n```\n1. Request arrives\n   ↓\n2. Estimate cost (Step 1)\n   ↓\n3. Reserve credits atomically\n   ├─ Check balance\n   ├─ Deduct estimated amount\n   └─ Create reservation record\n   ↓\n4. Make LLM API call\n   ↓\n5. Adjust based on token usage (Step 2)\n   ├─ Calculate actual cost\n   ├─ Adjust balance (refund/charge difference)\n   └─ Store generation ID\n   ↓\n6. Queue cost verification (Step 3)\n   ↓\n7. Finalize with OpenRouter cost\n   ├─ Fetch cost from OpenRouter API\n   ├─ Make final adjustment\n   ├─ Update conversation\n   └─ Delete reservation\n```\n\n### Reservation Record\n\nReservations are stored in the `credit-reservations` table:\n\n```typescript\n{\n  pk: \"credit-reservations/{reservationId}\",\n  workspaceId: string,\n  reservedAmount: number,        // Estimated cost (Step 1)\n  estimatedCost: number,         // Same as reservedAmount\n  tokenUsageBasedCost?: number,  // Actual cost from tokens (Step 2)\n  openrouterCost?: number,        // Final cost from OpenRouter (Step 3)\n  openrouterGenerationId?: string, // For Step 3 lookup\n  provider?: string,\n  modelName?: string,\n  currency: \"usd\",\n  expires: number,               // TTL timestamp (15 minutes)\n  expiresHour: number            // For GSI queries\n}\n```\n\n### Atomic Operations\n\nAll credit operations use DynamoDB's `atomicUpdate` to ensure thread-safety:\n\n```typescript\nawait db.workspace.atomicUpdate(\n  workspacePk,\n  \"workspace\",\n  async (current) => {\n    if (current.creditBalance < estimatedCost) {\n      throw new InsufficientCreditsError(...)\n    }\n    return {\n      pk: workspacePk,\n      sk: \"workspace\",\n      creditBalance: current.creditBalance - estimatedCost,\n    }\n  },\n  { maxRetries: 3 }\n)\n```\n\nThis ensures:\n- **No race conditions**: Multiple concurrent requests don't over-deduct\n- **Accurate balances**: Credit balance is always correct\n- **Automatic retries**: Handles version conflicts automatically\n\n### Reservation TTL\n\nReservations have a 15-minute TTL to prevent orphaned records:\n\n- **TTL**: 15 minutes from creation\n- **Automatic cleanup**: DynamoDB automatically deletes expired records\n- **Backup cleanup**: Scheduled function also cleans up expired reservations\n\n### Error Handling\n\n**Insufficient Credits**:\n- Thrown when balance < estimated cost\n- Prevents LLM call from proceeding\n- Returns clear error message to user\n\n**Missing Reservation**:\n- If reservation not found during adjustment, assumes already processed\n- Logs warning but doesn't fail the request\n- Safe because credits were either never reserved or already adjusted\n\n**Failed Cost Verification**:\n- If OpenRouter API fails, reservation expires via TTL\n- Token usage-based cost (Step 2) is used as final cost\n- No user impact, but may result in slight cost discrepancy\n\n## Credit Deduction in Workspace\n\n### Workspace Credit Balance\n\nEach workspace maintains a credit balance:\n\n```typescript\n{\n  pk: \"workspaces/{workspaceId}\",\n  sk: \"workspace\",\n  creditBalance: number,  // In nano-dollars (integer)\n  currency: \"usd\"\n}\n```\n\n### Deduction Flow\n\n1. **Reservation (Step 1)**: Credits are deducted immediately when reservation is created\n2. **Adjustment (Step 2)**: Balance is adjusted based on actual token usage\n3. **Finalization (Step 3)**: Final adjustment based on OpenRouter cost\n\n### Negative Balances\n\nNegative credit balances are **allowed**:\n\n- Workspaces can go into negative balance\n- Prevents blocking legitimate requests due to timing issues\n- Workspaces should monitor balance and add credits\n\n### BYOK (Bring Your Own Key)\n\nWhen a workspace uses their own OpenRouter API key:\n\n- **Reservation**: Skipped (no credit deduction)\n- **Adjustment**: Skipped (no credit adjustment)\n- **Finalization**: Skipped (no cost verification)\n- **Token Tracking**: Still tracked for analytics\n- **Coverage**: Applies to both LLM calls and embeddings\n\nThe workspace pays directly to OpenRouter, bypassing Helpmaton's credit system.\n\n## Cost Verification Queue\n\nThe cost verification queue (`openrouter-cost-verification-queue`) processes Step 3 verifications:\n\n### Queue Configuration\n\n- **Type**: SQS FIFO queue\n- **Message Group**: Per workspace (ensures sequential processing)\n- **Visibility Timeout**: 30 seconds\n- **Dead Letter Queue**: Configured for failed messages\n\n### Message Format\n\n```typescript\n{\n  reservationId?: string,           // Optional (not required for BYOK)\n  openrouterGenerationId: string,      // Required\n  workspaceId: string,               // Required\n  conversationId?: string,            // Optional (for message updates)\n  agentId?: string                    // Optional (for message updates)\n}\n```\n\n### Processing\n\n1. **Fetch Cost**: Queries OpenRouter API for generation cost\n2. **Finalize Reservation**: Calls `finalizeCreditReservation()` if reservationId provided\n3. **Update Message**: Updates conversation message with `finalCostUsd` if conversation context available\n4. **Error Handling**: Logs errors but doesn't fail (best-effort verification)\n\n### Partial Batch Failures\n\nThe queue supports partial batch failures:\n- Successful messages are deleted immediately\n- Failed messages are retried individually\n- Prevents reprocessing of successful messages\n\n## Feature Flags\n\nCredit system behavior can be controlled via environment variables:\n\n- **`ENABLE_CREDIT_VALIDATION`**: Controls credit balance validation (default: `true`)\n  - When disabled: Skips credit balance checks\n  - Still allows reservation creation if `ENABLE_CREDIT_DEDUCTION` is enabled\n\n- **`ENABLE_CREDIT_DEDUCTION`**: Controls credit reservation and deduction (default: `true`)\n  - When disabled: No reservations created, no credits deducted\n  - Useful for testing or maintenance\n\n- **`ENABLE_SPENDING_LIMIT_CHECKS`**: Controls spending limit validation (default: `true`)\n  - When disabled: Skips spending limit checks\n  - Limits are still stored but not enforced\n\n## Monitoring and Troubleshooting\n\n### Key Metrics\n\n- **Reservation Creation Rate**: Number of reservations created per minute\n- **Reservation Expiration Rate**: Number of reservations expiring without finalization\n- **Cost Verification Success Rate**: Percentage of successful Step 3 verifications\n- **Credit Balance Trends**: Average credit balance over time\n\n### Common Issues\n\n**Credits Not Deducted**:\n- Check if BYOK is enabled (skips deduction)\n- Verify `ENABLE_CREDIT_DEDUCTION` is enabled\n- Check reservation records in DynamoDB\n- Review error logs for atomic update failures\n\n**Cost Verification Failures**:\n- Check OpenRouter API availability\n- Verify `OPENROUTER_API_KEY` is set correctly\n- Review queue processing logs\n- Check for generation ID mismatches\n\n**Pricing Out of Date**:\n- Verify GitHub Actions workflow is running\n- Check `lastUpdated` in `pricing.json`\n- Manually trigger pricing update: `pnpm update-pricing`\n- Review pricing update logs for errors\n\n## Related Documentation\n\n- [Credit System](./credit-system.md) - Detailed credit reservation and adjustment flows\n- [Pricing Calculation](./pricing-calculation.md) - Token cost calculation formulas and examples\n- [Database Schema](./database-schema.md) - Database table structures\n\n## Implementation Files\n\n- **Pricing Configuration**: `apps/backend/src/config/pricing.json`\n- **Pricing Logic**: `apps/backend/src/utils/pricing.ts`\n- **Credit Management**: `apps/backend/src/utils/creditManagement.ts`\n- **Cost Verification Queue**: `apps/backend/src/queues/openrouter-cost-verification-queue/index.ts`\n- **Price Update Script**: `scripts/update-pricing.mjs`\n- **Price Update Workflow**: `.github/workflows/update-pricing.yml`\n\n",
  "troubleshooting": "# Troubleshooting Guide\n\nCommon issues and solutions when using Helpmaton.\n\n## Upload Issues\n\n### File Upload Fails\n\n**Problem**: Files won't upload or upload fails with an error.\n\n**Solutions**:\n- Check file size (max 10MB per file)\n- Verify file type is supported (.md, .txt, .markdown)\n- Ensure you have WRITE permission on the workspace\n- Check your internet connection\n- Try refreshing the page and uploading again\n\n### Filename Conflicts\n\n**Problem**: Uploaded file gets a different name than expected.\n\n**Solution**: This is expected behavior. If a filename already exists in the destination folder, Helpmaton automatically appends a number (e.g., `document-1.md`, `document-2.md`) to prevent conflicts.\n\n## Document Management\n\n### Can't Edit Document\n\n**Problem**: Document viewer doesn't allow editing.\n\n**Solutions**:\n- Verify you have WRITE permission on the workspace\n- Check that the document loaded correctly\n- Try refreshing the page\n\n### Document Not Found\n\n**Problem**: Document appears to be missing or can't be opened.\n\n**Solutions**:\n- Check that you're in the correct folder\n- Verify the document wasn't deleted\n- Ensure you have READ permission on the workspace\n- Try navigating to the root folder and searching\n\n### Folder Navigation Issues\n\n**Problem**: Can't navigate to a folder or folder structure seems wrong.\n\n**Solutions**:\n- Use breadcrumbs to navigate back\n- Check folder path format (use forward slashes for nesting)\n- Ensure folder names don't contain invalid characters\n- Try refreshing the page\n\n## Agent Issues\n\n### Agent Not Responding\n\n**Problem**: Agent webhook or test endpoint doesn't return responses.\n\n**Solutions**:\n- Verify the webhook key is correct\n- Check that the agent exists and is properly configured\n- Ensure the system prompt is valid\n- Review server logs for errors\n\n### Agent Responses Are Unexpected\n\n**Problem**: Agent behavior doesn't match expectations.\n\n**Solutions**:\n- Review and refine the system prompt\n- Upload relevant documents to provide context\n- Test with different inputs to understand behavior\n- Consider breaking complex prompts into simpler instructions\n\n## Permission Issues\n\n### Can't Create or Edit Resources\n\n**Problem**: Buttons are disabled or actions fail with permission errors.\n\n**Solutions**:\n- Verify your permission level (need WRITE or OWNER)\n- Contact workspace owner to request higher permissions\n- Check that you're logged in with the correct account\n\n### Can't Delete Workspace\n\n**Problem**: Delete workspace button is missing or disabled.\n\n**Solution**: Only workspace owners can delete workspaces. Contact the workspace owner if you need this action performed.\n\n## General Issues\n\n### Page Won't Load\n\n**Problem**: Workspace or document page doesn't load.\n\n**Solutions**:\n- Check your internet connection\n- Verify you're logged in\n- Try refreshing the page\n- Clear browser cache and cookies\n- Check browser console for errors\n\n### Changes Not Saving\n\n**Problem**: Edits to documents or agents don't persist.\n\n**Solutions**:\n- Ensure you clicked \"SAVE\" button\n- Check for error messages\n- Verify you have WRITE permission\n- Try refreshing and editing again\n\n## Getting Help\n\nIf you continue to experience issues:\n\n1. Check the browser console for error messages\n2. Review server logs if you have access\n3. Verify your permissions and workspace access\n4. Try the action in a different browser\n5. Contact your workspace administrator\n\n",
  "authentication": "# Authentication System\n\nThis document describes the authentication system in Helpmaton, including session-based authentication, JWT tokens, API keys, and OAuth providers.\n\n## Overview\n\nHelpmaton supports multiple authentication methods:\n\n1. **Session-based** (Cookies): For web UI\n2. **JWT Tokens**: For API access\n3. **API Keys**: For programmatic access\n4. **Magic Links**: Passwordless email authentication\n5. **Passkeys (WebAuthn)**: Passwordless sign-in with device biometrics or security key\n6. **OAuth**: Gmail and Outlook integration\n\n## Session-Based Authentication\n\n### How It Works\n\nSession-based authentication uses HTTP cookies to maintain user sessions:\n\n1. User logs in via magic link or OAuth\n2. Backend creates a session cookie\n3. Cookie is sent with subsequent requests\n4. Backend validates cookie and extracts user info\n\n### Session Storage\n\nSessions are stored in the `next-auth` table (DynamoDB):\n\n- **Partition Key**: Session ID\n- **TTL**: Automatic expiration\n- **Encryption**: Encrypted at rest\n\n### Session Lifecycle\n\n1. **Creation**: Session created on login\n2. **Validation**: Session validated on each request\n3. **Refresh**: Session refreshed on activity\n4. **Expiration**: Session expires after inactivity\n\n### Usage\n\nSessions are automatically handled by NextAuth.js (Auth.js):\n\n```typescript\n// Backend automatically extracts session from cookies\nconst session = await requireSessionFromRequest(req);\nconst userId = session.user.id;\n```\n\n## JWT Token Authentication\n\n### Access Tokens\n\nShort-lived JWT tokens for API access:\n\n- **Lifetime**: 1 hour (configurable)\n- **Format**: JWT (JSON Web Token)\n- **Signing**: HMAC SHA-256 with `AUTH_SECRET`\n\n### Refresh Tokens\n\nLong-lived tokens for refreshing access tokens:\n\n- **Lifetime**: 30 days (configurable)\n- **Storage**: `user-refresh-token` table (DynamoDB)\n- **Encryption**: Hashed with scrypt\n\n### Token Flow\n\n```\nUser logs in\n    │\n    ▼\nBackend generates:\n  - Access token (JWT, 24 hours)\n  - Refresh token (stored in DB, 30 days)\n    │\n    ▼\nClient stores tokens\n    │\n    ▼\nAPI requests include:\n  Authorization: Bearer <access_token>\n    │\n    ▼\nBackend validates JWT\n    │\n    ├─ Valid → Process request\n    └─ Expired → Use refresh token\n         │\n         ▼\n    Generate new access token\n```\n\n### Generating Tokens\n\n**Endpoint**:\n\n```\nPOST /api/user/tokens\n```\n\n**Request**: Requires session cookie or existing access token\n\n**Response**:\n\n```json\n{\n  \"accessToken\": \"eyJhbGciOiJIUzI1NiIs...\",\n  \"refreshToken\": \"refresh_token_123\",\n  \"expiresIn\": 3600\n}\n```\n\n### Refreshing Tokens\n\n**Endpoint**:\n\n```\nPOST /api/user/refresh\n```\n\n**Request Body**:\n\n```json\n{\n  \"refreshToken\": \"refresh_token_123\"\n}\n```\n\n**Response**:\n\n```json\n{\n  \"accessToken\": \"eyJhbGciOiJIUzI1NiIs...\",\n  \"expiresIn\": 3600\n}\n```\n\n### Using Tokens\n\nInclude in `Authorization` header:\n\n```bash\ncurl -H \"Authorization: Bearer eyJhbGciOiJIUzI1NiIs...\" \\\n  https://app.helpmaton.com/api/workspaces\n```\n\n### Token Validation\n\nBackend validates tokens:\n\n```typescript\n// Verify JWT access token\nconst tokenPayload = await verifyAccessToken(bearerToken);\nconst userId = tokenPayload.userId;\n```\n\n## API Key Authentication\n\n### User API Keys\n\nUser-level API keys for programmatic access:\n\n- **Format**: `hmat_` prefix + random string\n- **Storage**: `user-api-key` table (DynamoDB)\n- **Security**: Hashed with scrypt, SHA256 for lookup\n\n### Creating User API Keys\n\n**Endpoint**:\n\n```\nPOST /api/user/api-keys\n```\n\n**Request Body**:\n\n```json\n{\n  \"name\": \"My API Key\"\n}\n```\n\n**Response**:\n\n```json\n{\n  \"id\": \"key_123\",\n  \"name\": \"My API Key\",\n  \"keyPrefix\": \"hmat_abc...\",\n  \"key\": \"hmat_abc123def456...\", // Only shown once!\n  \"createdAt\": \"2024-01-01T00:00:00Z\"\n}\n```\n\n**Important**: The full key is only shown once. Store it securely.\n\n### Using User API Keys\n\nInclude in `Authorization` header:\n\n```bash\ncurl -H \"Authorization: Bearer hmat_abc123def456...\" \\\n  https://app.helpmaton.com/api/workspaces\n```\n\n### Key Validation\n\nBackend validates keys:\n\n1. Extract key from `Authorization` header\n2. Compute SHA256 hash for lookup\n3. Query `user-api-key` table via GSI\n4. Verify key with scrypt\n5. Update `lastUsedAt` timestamp\n\n### Workspace API Keys\n\nWorkspace-level API keys for BYOK (Bring Your Own Key):\n\n- **Purpose**: Use workspace's own LLM API key\n- **Storage**: `workspace-api-key` table\n- **Usage**: Automatically used when configured\n\n## Magic Link Authentication\n\n### How It Works\n\nPasswordless authentication via email:\n\n1. User enters email address\n2. Backend generates secure token\n3. Email sent with magic link\n4. User clicks link\n5. Backend validates token\n6. Session created\n\n### Requesting Magic Link\n\n**Endpoint**:\n\n```\nPOST /api/auth/signin/email\n```\n\n**Request Body**:\n\n```json\n{\n  \"email\": \"user@example.com\"\n}\n```\n\n**Response**:\n\n```json\n{\n  \"message\": \"Check your email for a magic link\"\n}\n```\n\n### Magic Link Format\n\n```\nhttps://app.helpmaton.com/api/auth/callback/email?token=secure_token_123\n```\n\n### Token Validation\n\n- Tokens are single-use\n- Tokens expire after 24 hours\n- Tokens are cryptographically secure\n\n## Passkey (WebAuthn) Authentication\n\n### How It Works\n\nPasswordless sign-in using WebAuthn:\n\n1. **Registration (after login)**: User creates a passkey from Settings (Sign-in methods). Backend generates creation options, browser creates credential, backend verifies and stores it in the `next-auth` table (DynamoDB).\n2. **Login**: User clicks \"Sign in with passkey\" on the login page. Backend returns authentication options (challenge stored in signed cookie). Browser prompts for authenticator; backend verifies assertion, looks up user by credential ID, issues a short-lived one-time JWT. Frontend calls Auth.js Credentials provider with that token to establish the same session as magic link.\n\n### Registration Flow\n\n**Endpoints** (require session):\n\n- `POST /api/user/passkey/register/options` – Returns WebAuthn creation options and sets challenge cookie.\n- `POST /api/user/passkey/register/verify` – Body: credential (RegistrationResponseJSON). Verifies and stores passkey; returns `{ verified: true }`.\n\n### Login Flow\n\n**Endpoints** (no auth):\n\n- `GET /api/user/passkey/login/options` – Returns WebAuthn request options and sets challenge cookie.\n- `POST /api/user/passkey/login/verify` – Body: assertion (AuthenticationResponseJSON). Verifies assertion, updates counter, returns `{ token }` (one-time JWT for Auth.js).\n\nFrontend then calls `signIn(\"passkey\", { token, callbackUrl, redirect: false })`; Auth.js Credentials provider verifies the token and creates the same session as email sign-in.\n\n### Data and Security\n\n- **Storage**: Passkeys stored in the `next-auth` table (pk=USER#userId, sk=PASSKEY#credentialId). GSI `byCredentialId` (gsi2pk/gsi2sk) for login lookup (no table scans).\n- **Challenges**: Register challenge bound to session; login challenge in signed HTTP-only cookie. Verified once and discarded.\n- **Origin/rpId**: Set from backend config (e.g. `FRONTEND_URL`); verification rejects wrong origin.\n\n## OAuth Authentication\n\n### Supported Providers\n\n- **Gmail**: Google OAuth 2.0\n- **Outlook**: Microsoft Azure AD OAuth 2.0\n\n### Gmail OAuth\n\n**Configuration**:\n\n1. Create OAuth client in Google Cloud Console\n2. Set redirect URI: `{BASE_URL}/api/auth/callback/google`\n3. Configure `GOOGLE_OAUTH_CLIENT_ID` and `GOOGLE_OAUTH_CLIENT_SECRET`\n\n**Flow**:\n\n```\nUser clicks \"Sign in with Google\"\n    │\n    ▼\nRedirect to Google OAuth\n    │\n    ▼\nUser authorizes\n    │\n    ▼\nGoogle redirects to callback\n    │\n    ▼\nBackend exchanges code for tokens\n    │\n    ▼\nCreate/update user account\n    │\n    ▼\nCreate session\n    │\n    ▼\nRedirect to frontend\n```\n\n### Outlook OAuth\n\n**Configuration**:\n\n1. Create app registration in Azure Portal\n2. Set redirect URI: `{BASE_URL}/api/auth/callback/outlook`\n3. Configure `OUTLOOK_CLIENT_ID` and `OUTLOOK_CLIENT_SECRET`\n\n**Flow**: Similar to Gmail OAuth\n\n## Authentication Middleware\n\n### Require Authentication\n\nMiddleware to require authentication:\n\n```typescript\n// Require Bearer token (JWT or API key)\nexport const requireAuth = async (req, res, next) => {\n  const bearerToken = extractBearerToken(req);\n  if (!bearerToken) {\n    throw unauthorized(\"Bearer token required\");\n  }\n\n  // Try JWT first, fall back to API key\n  const tokenPayload = await verifyAccessToken(bearerToken);\n  req.userRef = userRef(tokenPayload.userId);\n  next();\n};\n```\n\n### Require Session\n\nMiddleware to require session cookie:\n\n```typescript\n// Require session cookie\nexport const requireSession = async (req, res, next) => {\n  const session = await requireSessionFromRequest(req);\n  if (!session.user?.id) {\n    throw unauthorized();\n  }\n  req.session = session;\n  req.userRef = userRef(session.user.id);\n  next();\n};\n```\n\n### Require Auth or Session\n\nMiddleware that accepts either:\n\n```typescript\n// Accept Bearer token OR session cookie\nexport const requireAuthOrSession = async (req, res, next) => {\n  // Try Bearer token first\n  const bearerToken = extractBearerToken(req);\n  if (bearerToken) {\n    try {\n      const tokenPayload = await verifyAccessToken(bearerToken);\n      req.userRef = userRef(tokenPayload.userId);\n      return next();\n    } catch {\n      // Fall through to session\n    }\n  }\n\n  // Fall back to session\n  const session = await requireSessionFromRequest(req);\n  req.session = session;\n  req.userRef = userRef(session.user.id);\n  next();\n};\n```\n\n## Security\n\n### Token Security\n\n- **JWT Signing**: HMAC SHA-256 with secret key\n- **API Key Hashing**: scrypt with salt\n- **Token Storage**: Never store tokens in localStorage (use httpOnly cookies or secure storage)\n- **Token Rotation**: Refresh tokens can be rotated\n\n### Key Security\n\n- **Hashing**: API keys are hashed with scrypt\n- **Lookup**: SHA256 hash for fast lookup (not for validation)\n- **Storage**: Keys encrypted at rest in DynamoDB\n- **Rotation**: Keys can be deleted and recreated\n\n### Session Security\n\n- **HttpOnly Cookies**: Prevents XSS attacks\n- **Secure Cookies**: HTTPS only in production\n- **SameSite**: CSRF protection\n- **Expiration**: Automatic expiration\n\n## Best Practices\n\n### For Users\n\n1. **Store tokens securely**: Use secure storage, never commit to version control\n2. **Rotate keys regularly**: Delete and recreate API keys periodically\n3. **Use different keys**: Use different keys for different applications\n4. **Monitor usage**: Check `lastUsedAt` timestamps\n\n### For Developers\n\n1. **Validate tokens**: Always validate tokens on the backend\n2. **Handle expiration**: Implement token refresh logic\n3. **Error handling**: Return clear error messages\n4. **Rate limiting**: Implement rate limiting for auth endpoints\n\n## API Reference\n\n### Authentication Endpoints\n\n- `POST /api/auth/signin/email` - Request magic link\n- `GET /api/auth/callback/email` - Magic link callback\n- `GET /api/auth/callback/google` - Google OAuth callback\n- `GET /api/auth/callback/outlook` - Outlook OAuth callback\n- `POST /api/user/passkey/register/options` - Passkey registration options (session required)\n- `POST /api/user/passkey/register/verify` - Passkey registration verify (session required)\n- `GET /api/user/passkey/login/options` - Passkey login options (no auth)\n- `POST /api/user/passkey/login/verify` - Passkey login verify, returns one-time token (no auth)\n- `POST /api/user/tokens` - Generate access/refresh tokens\n- `POST /api/user/refresh` - Refresh access token\n- `POST /api/user/api-keys` - Create user API key\n- `GET /api/user/api-keys` - List user API keys\n- `DELETE /api/user/api-keys/:keyId` - Delete user API key\n\nSee [API Reference](./api-reference.md) for complete documentation.\n\n## Troubleshooting\n\n### Token Validation Fails\n\n- Check `AUTH_SECRET` is set correctly\n- Verify token hasn't expired\n- Ensure token format is correct (Bearer token)\n\n### Session Not Persisting\n\n- Check cookies are enabled\n- Verify `AUTH_SECRET` is set\n- Check cookie domain/path settings\n- Clear browser cookies and try again\n\n### API Key Not Working\n\n- Verify key format is correct\n- Check key hasn't been deleted\n- Ensure key is included in `Authorization` header\n- Verify key belongs to correct user\n\n### OAuth Not Working\n\n- Check OAuth credentials are configured\n- Verify redirect URIs match exactly\n- Check OAuth consent screen is configured\n- Review OAuth provider logs\n",
  "subscription-management": "# Subscription Management\n\nThis document describes the subscription system in Helpmaton, including plans, limits, and management rules.\n\n## Overview\n\nHelpmaton supports subscription-based access control with three plans: **free**, **starter**, and **pro**. Each subscription belongs to a user and can have multiple managers. Workspaces are associated with subscriptions, and all limits are enforced at the subscription level.\n\n## Subscription Plans\n\n### Free Plan\n\n- **Maximum workspaces**: 1\n- **Maximum documents**: 10\n- **Maximum total document size**: 1 MB\n- **Maximum agents**: 1 (total across all workspaces)\n- **Maximum managers**: 1\n- **Maximum daily requests**: 25 LLM requests per 24 hours (rolling window)\n- **Maximum users**: 1 team member\n- **Maximum webhooks**: 5\n- **Maximum channels**: 2 output channels\n- **Maximum MCP servers**: 2\n- **Expiration**: None (free plans never expire)\n\n### Starter Plan\n\n- **Maximum workspaces**: 1\n- **Maximum documents**: 100\n- **Maximum total document size**: 10 MB\n- **Maximum agents**: 5 (total across all workspaces)\n- **Maximum managers**: 1\n- **Maximum daily requests**: 3,000 LLM requests per 24 hours (rolling window)\n- **Maximum users**: 1 team member\n- **Maximum webhooks**: 25\n- **Maximum channels**: 10 output channels\n- **Maximum MCP servers**: 10\n- **Expiration**: None (active until cancelled or upgraded)\n\n### Pro Plan\n\n- **Maximum workspaces**: 5\n- **Maximum documents**: 1000\n- **Maximum total document size**: 100 MB\n- **Maximum agents**: 50 (total across all workspaces)\n- **Maximum managers**: Unlimited\n- **Maximum daily requests**: 10,000 LLM requests per 24 hours (rolling window)\n- **Maximum users**: 5 team members\n- **Maximum webhooks**: 250\n- **Maximum channels**: 50 output channels\n- **Maximum MCP servers**: 50\n- **Expiration**: None (active until cancelled or upgraded)\n\n## User Subscription Limit\n\n- **Each user can only have one subscription**\n- When a user first creates a workspace, a free subscription is automatically created for them\n- The user who creates the subscription becomes the subscription owner\n- The subscription owner has full manager permissions\n- Users cannot have multiple subscriptions\n\n## Subscription Ownership\n\n### Initial Ownership\n\n- When a user first creates a workspace, a free subscription is automatically created for them\n- The user who creates the subscription becomes the subscription owner\n- The subscription owner has full manager permissions\n\n### Subscription Association\n\n- Each workspace belongs to exactly one subscription\n- When a workspace is created, it is automatically associated with the creator's subscription\n- If a user has no subscription, a free subscription is created automatically (auto-migration)\n\n## Manager Management\n\n### Manager Roles\n\n- **Managers** are users who have permission to manage a subscription\n- All managers have equal permissions (OWNER level on the subscription resource)\n- Managers can:\n  - Add other users as managers\n  - Remove other managers (with restrictions)\n  - Access all workspaces in the subscription (based on workspace permissions)\n\n### Adding Managers\n\n**Rules for adding a manager:**\n\n1. The user adding the manager must be a manager of the subscription\n2. The subscription must not have reached its manager limit:\n   - Free and starter plans can only have 1 manager max\n   - Pro plans have unlimited managers\n3. The user being added must meet one of these conditions:\n   - Have no subscription, OR\n   - Be in a free subscription (they can be added as a manager, but their old free subscription is not automatically removed or transferred)\n\n**API Endpoints:**\n\n```\nPOST /api/subscription/managers/:userId\nPOST /api/subscriptions/:subscriptionId/managers/:userId\n```\n\n**Authorization:** Requires manager permission on the subscription\n\n**Validation:**\n\n- Checks that the current user is a manager\n- Validates that the subscription has not reached its manager limit (for free/starter plans)\n- Validates that the target user can be added (no subscription or free subscription only)\n- Creates manager permission for the target user\n\n### Removing Managers\n\n**Rules for removing a manager:**\n\n1. The user removing the manager must be a manager of the subscription\n2. The subscription must have more than one manager (prevents orphaned subscriptions)\n3. A manager cannot remove themselves if they are the last manager\n\n**API Endpoints:**\n\n```\nDELETE /api/subscription/managers/:userId\nDELETE /api/subscriptions/:subscriptionId/managers/:userId\n```\n\n**Authorization:** Requires manager permission on the subscription\n\n**Validation:**\n\n- Checks that the current user is a manager\n- Validates that there is more than one manager (prevents orphan)\n- Removes manager permission for the target user\n\n## Limit Enforcement\n\n### Workspace Limits\n\n- Enforced when creating a new workspace\n- Counts all workspaces associated with the subscription\n- Returns error if limit would be exceeded\n\n### Document Limits\n\n- Enforced when uploading documents\n- Checks both document count and total size\n- Counts all documents across all workspaces in the subscription\n- Returns error if either limit would be exceeded\n\n### Agent Limits\n\n- Enforced when creating a new agent\n- Counts all agents across all workspaces in the subscription\n- Returns error if limit would be exceeded\n\n### Webhook Limits\n\n- Enforced when creating a new webhook\n- Counts all webhooks across all agents in the subscription\n- Returns error if limit would be exceeded\n\n### Channel Limits\n\n- Enforced when creating a new output channel\n- Counts all channels across all workspaces in the subscription\n- Returns error if limit would be exceeded\n\n### MCP Server Limits\n\n- Enforced when creating a new MCP server\n- Counts all MCP servers across all workspaces in the subscription\n- Returns error if limit would be exceeded\n\n### User Limits\n\n- Enforced when adding a user to a workspace\n- Counts all unique users across all workspaces in the subscription\n- Returns error if limit would be exceeded\n\n### Daily Request Limits\n\n- Enforced when executing agents (test endpoint and webhook endpoint)\n- Tracks LLM requests per subscription using a rolling 24-hour window\n- If daily request limit is exceeded, agent execution is blocked\n- Returns error message indicating request limit exceeded\n- Limits reset automatically as requests age out of the 24-hour window\n\n## Auto-Migration\n\n### Existing Users\n\n- When a user without a subscription accesses the system (e.g., creates a workspace), a free subscription is automatically created\n- This handles migration of existing users who were created before subscriptions were introduced\n\n### Existing Workspaces\n\n- When a workspace without a `subscriptionId` is accessed, it is automatically associated with the user's subscription\n- This handles migration of existing workspaces created before subscriptions were introduced\n\n## Subscription Lifecycle\n\n1. **Creation**: Free subscription created automatically when user first creates a workspace\n2. **Association**: Workspaces are associated with subscriptions at creation time\n3. **Management**: Managers can be added/removed (with restrictions)\n4. **Expiration**: Free plans never expire (active indefinitely)\n5. **Upgrade/Downgrade**: (Future feature - not yet implemented)\n\n## Payment Failures and Grace Period (Lemon Squeezy)\n\n- **Missed payment**: When Lemon Squeezy sends `subscription_past_due`, the subscription is marked `past_due` and a **7-day grace period** starts (`gracePeriodEndsAt = now + 7 days`). A payment failure email is sent.\n- **Status updates**: If Lemon Squeezy later reports `unpaid` via `subscription_updated`, we persist that status as-is.\n- **Grace period warnings**: During the grace period, we send a warning email when **3 days or fewer** remain (no more than once every 24 hours).\n- **Grace period expiry**: Once the grace period ends (or Lemon Squeezy emits `subscription_expired`), the subscription is **downgraded to free** and marked `expired`. We clear Lemon Squeezy IDs and billing fields (`renewsAt`, `endsAt`) and remove the sync key. A downgrade email is sent.\n\n## API Endpoints\n\n### Get Current User's Subscription\n\n**GET `/api/subscription`**\n\nReturns the current user's subscription details including plan, expiration, and list of managers with their emails.\n\n**Response:**\n\n```json\n{\n  \"subscriptionId\": \"uuid\",\n  \"plan\": \"free\" | \"starter\" | \"pro\",\n  \"expiresAt\": \"2024-01-01T00:00:00Z\" | null,\n  \"createdAt\": \"2024-01-01T00:00:00Z\",\n  \"managers\": [\n    {\n      \"userId\": \"user-id\",\n      \"email\": \"user@example.com\" | null\n    }\n  ]\n}\n```\n\n### Find User by Email\n\n**GET `/api/users/by-email/:email`**\n\nFinds a user by their email address. Used to validate that a user exists before adding them as a manager.\n\n**Response:**\n\n```json\n{\n  \"userId\": \"user-id\",\n  \"email\": \"user@example.com\"\n}\n```\n\n**Errors:**\n\n- 404: User not found\n\n## Error Messages\n\nCommon error messages users may encounter:\n\n- **Workspace limit exceeded**: \"Workspace limit exceeded. Maximum {N} workspace(s) allowed for {plan} plan.\"\n- **Document count limit exceeded**: \"Document count limit exceeded. Maximum {N} document(s) allowed for {plan} plan.\"\n- **Document size limit exceeded**: \"Document size limit exceeded. Maximum {N} MB total size allowed for {plan} plan.\"\n- **Agent limit exceeded**: \"Agent limit exceeded. Maximum {N} agent(s) allowed for {plan} plan.\"\n- **Daily request limit exceeded**: \"Daily request limit exceeded. Maximum {N} request(s) per 24 hours allowed for {plan} plan.\"\n- **User limit exceeded**: \"User limit exceeded. Maximum {N} user(s) allowed for {plan} plan.\"\n- **Webhook limit exceeded**: \"Webhook limit exceeded. Maximum {N} webhook(s) allowed for {plan} plan.\"\n- **Channel limit exceeded**: \"Channel limit exceeded. Maximum {N} channel(s) allowed for {plan} plan.\"\n- **MCP server limit exceeded**: \"MCP server limit exceeded. Maximum {N} MCP server(s) allowed for {plan} plan.\"\n- **Cannot add manager**: \"User already has a non-free subscription and cannot be added as a manager.\"\n- **Manager limit reached**: \"Free and starter plans can only have one manager. This subscription already has the maximum number of managers.\"\n- **Cannot remove last manager**: \"Cannot remove the last manager. A subscription must have at least one manager.\"\n\n## Best Practices\n\n1. **Plan Selection**: Choose a plan that matches your expected usage\n2. **Manager Management**: Only add trusted users as managers\n3. **Workspace Organization**: Organize workspaces within subscription limits\n4. **Document Management**: Monitor document count and size to avoid hitting limits\n5. **Daily Request Limits**: Monitor your daily request usage to avoid hitting limits, especially on free and starter plans\n6. **Free Plan**: Free plans never expire and remain active indefinitely\n\n## Technical Details\n\n### Centralized Limits\n\nAll subscription limits (workspaces, documents, agents, managers, daily requests, users, webhooks, channels, and MCP servers) are defined in a single file: `apps/backend/src/utils/subscriptionPlans.ts`. This ensures consistency and makes it easy to update limits by modifying a single source of truth.\n\n### Database Schema\n\n- **Subscription table**: Stores subscription records with plan, expiration, and user ID\n- **Workspace table**: Includes `subscriptionId` field to associate workspaces with subscriptions\n- **Permission table**: Used to manage manager permissions (resourceType: \"subscriptions\")\n\n### Indexes\n\n- **byUserId GSI**: Allows querying subscriptions by user ID for efficient lookups\n\n### Permission Model\n\n- Subscriptions use the same permission system as workspaces\n- Manager permissions are stored as OWNER level permissions on the subscription resource\n- Resource type is \"subscriptions\" for subscription permissions\n",
  "mcp-servers": "# MCP Server Integration\n\nThis document explains how to configure and use MCP (Model Context Protocol) servers in Helpmaton to extend agent capabilities with external tools.\n\n## Overview\n\nMCP (Model Context Protocol) servers allow agents to call external services and tools. Helpmaton integrates with MCP servers by creating tools dynamically from server configurations, enabling agents to interact with external APIs and services.\n\n## What are MCP Servers?\n\nMCP servers are external services that expose tools and capabilities via the MCP protocol (JSON-RPC 2.0). Agents can call these tools to:\n\n- Access external APIs\n- Perform database queries\n- Execute custom business logic\n- Integrate with third-party services\n\n## MCP Protocol\n\nMCP uses JSON-RPC 2.0 for communication:\n\n### Request Format\n\n```json\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"unique-request-id\",\n  \"method\": \"method-name\",\n  \"params\": {\n    \"param1\": \"value1\",\n    \"param2\": \"value2\"\n  }\n}\n```\n\n### Response Format\n\n```json\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"unique-request-id\",\n  \"result\": {\n    \"data\": \"response data\"\n  }\n}\n```\n\n### Error Format\n\n```json\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"unique-request-id\",\n  \"error\": {\n    \"code\": -32603,\n    \"message\": \"Internal error\",\n    \"data\": \"Error details\"\n  }\n}\n```\n\n## Configuration\n\n### Creating an MCP Server\n\n**Endpoint**:\n\n```\nPOST /api/workspaces/:workspaceId/mcp-servers\n```\n\n**Request Body**:\n\n```json\n{\n  \"name\": \"Weather API\",\n  \"url\": \"https://api.weather.example.com/mcp\",\n  \"authType\": \"header\",\n  \"config\": {\n    \"headerValue\": \"Bearer token_123\"\n  }\n}\n```\n\n**Fields**:\n\n- `name` (String, required): User-friendly name for the server\n- `url` (String, required): MCP server URL (must be valid URL)\n- `authType` (String, required): Authentication type (\"none\", \"header\", or \"basic\")\n- `config` (Object, required): Authentication configuration\n\n**Response**:\n\n```json\n{\n  \"id\": \"server_123\",\n  \"name\": \"Weather API\",\n  \"url\": \"https://api.weather.example.com/mcp\",\n  \"authType\": \"header\",\n  \"createdAt\": \"2024-01-01T00:00:00Z\",\n  \"updatedAt\": \"2024-01-01T00:00:00Z\"\n}\n```\n\n### Authentication Types\n\n#### None\n\nNo authentication required:\n\n```json\n{\n  \"authType\": \"none\",\n  \"config\": {}\n}\n```\n\n#### Header\n\nCustom header authentication:\n\n```json\n{\n  \"authType\": \"header\",\n  \"config\": {\n    \"headerValue\": \"Bearer token_123\"\n  }\n}\n```\n\nThe header value is sent as `Authorization` header in requests.\n\n#### Basic\n\nHTTP Basic Authentication:\n\n```json\n{\n  \"authType\": \"basic\",\n  \"config\": {\n    \"username\": \"user\",\n    \"password\": \"pass\"\n  }\n}\n```\n\nCredentials are sent as HTTP Basic Auth.\n\n### PostHog MCP Server (Read-only)\n\nPostHog does not support OAuth. Configure it using a personal API key and a\nregional base URL:\n\n```json\n{\n  \"name\": \"PostHog Analytics\",\n  \"url\": \"https://eu.posthog.com\",\n  \"authType\": \"header\",\n  \"serviceType\": \"posthog\",\n  \"config\": {\n    \"apiKey\": \"phx_your_personal_api_key\"\n  }\n}\n```\n\n**Allowed PostHog base URLs**:\n\n- `https://us.posthog.com`\n- `https://eu.posthog.com`\n\nThe PostHog MCP tools are read-only and use the API key for authorization.\n\n### Updating an MCP Server\n\n**Endpoint**:\n\n```\nPUT /api/workspaces/:workspaceId/mcp-servers/:serverId\n```\n\n**Request Body**: Same as create, all fields optional\n\n### Getting MCP Server\n\n**Endpoint**:\n\n```\nGET /api/workspaces/:workspaceId/mcp-servers/:serverId\n```\n\n### Listing MCP Servers\n\n**Endpoint**:\n\n```\nGET /api/workspaces/:workspaceId/mcp-servers\n```\n\n**Response**:\n\n```json\n[\n  {\n    \"id\": \"server_123\",\n    \"name\": \"Weather API\",\n    \"url\": \"https://api.weather.example.com/mcp\",\n    \"authType\": \"header\",\n    \"createdAt\": \"2024-01-01T00:00:00Z\",\n    \"updatedAt\": \"2024-01-01T00:00:00Z\"\n  }\n]\n```\n\n### Deleting an MCP Server\n\n**Endpoint**:\n\n```\nDELETE /api/workspaces/:workspaceId/mcp-servers/:serverId\n```\n\n## Enabling MCP Servers for Agents\n\nMCP servers must be enabled for specific agents to be used:\n\n### Agent Configuration\n\nAgents have an `enabledMcpServerIds` field that lists enabled MCP server IDs:\n\n```json\n{\n  \"id\": \"agent_123\",\n  \"name\": \"My Agent\",\n  \"enabledMcpServerIds\": [\"server_123\", \"server_456\"]\n}\n```\n\n### Enabling Servers\n\n**Endpoint**:\n\n```\nPUT /api/workspaces/:workspaceId/agents/:agentId\n```\n\n**Request Body**:\n\n```json\n{\n  \"enabledMcpServerIds\": [\"server_123\", \"server_456\"]\n}\n```\n\n## Tool Creation\n\nWhen an agent with enabled MCP servers is called, tools are created dynamically:\n\n### Tool Structure\n\nEach MCP server creates a generic tool that can call any MCP method:\n\n```typescript\n{\n  name: \"mcp_{serverId}\",\n  description: \"Call the MCP server '{serverName}'. Provide the MCP method name and optional parameters.\",\n  parameters: {\n    method: {\n      type: \"string\",\n      description: \"The MCP method to call\"\n    },\n    params: {\n      type: \"object\",\n      description: \"Optional parameters for the MCP method\"\n    }\n  }\n}\n```\n\n### Tool Execution\n\nWhen the agent calls the tool:\n\n1. Extract `method` and `params` from tool arguments\n2. Build JSON-RPC 2.0 request\n3. Send request to MCP server URL\n4. Include authentication headers if configured\n5. Parse JSON-RPC 2.0 response\n6. Return result to agent\n\n### Example Tool Call\n\nAgent calls:\n\n```json\n{\n  \"toolName\": \"mcp_server_123\",\n  \"args\": {\n    \"method\": \"get_weather\",\n    \"params\": {\n      \"location\": \"London\"\n    }\n  }\n}\n```\n\nSystem sends to MCP server:\n\n```json\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"1234567890-abc123\",\n  \"method\": \"get_weather\",\n  \"params\": {\n    \"location\": \"London\"\n  }\n}\n```\n\n## Error Handling\n\n### MCP Server Errors\n\nIf the MCP server returns an error:\n\n```json\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"1234567890-abc123\",\n  \"error\": {\n    \"code\": -32603,\n    \"message\": \"Internal error\",\n    \"data\": \"Location not found\"\n  }\n}\n```\n\nThe error is formatted and returned to the agent:\n\n```\nError calling MCP server: Internal error - Location not found\n```\n\n### Network Errors\n\nIf the request fails (timeout, connection error, etc.):\n\n```\nError calling MCP server: MCP server request failed: 500 Internal Server Error\n```\n\n### Validation Errors\n\nIf the server is not found or doesn't belong to the workspace:\n\n```\nError: MCP server server_123 not found\n```\n\nor\n\n```\nError: MCP server server_123 does not belong to this workspace\n```\n\n## Security\n\n### Authentication\n\n- **Config Storage**: Authentication config is encrypted at rest in DynamoDB\n- **Header Values**: Header values are stored securely\n- **Basic Auth**: Username and password are stored securely\n\n### Validation\n\n- **URL Validation**: URLs are validated to be valid HTTP/HTTPS URLs\n- **Workspace Isolation**: MCP servers are isolated per workspace\n- **Agent Validation**: Only enabled servers can be called by agents\n\n### Timeout\n\n- **Request Timeout**: 30 seconds per MCP request\n- **Abort Signal**: Requests are aborted if timeout is exceeded\n\n## Best Practices\n\n### Server Design\n\n1. **Clear Methods**: Use descriptive method names\n2. **Parameter Validation**: Validate parameters on the server side\n3. **Error Messages**: Provide clear error messages\n4. **Response Format**: Return structured JSON responses\n\n### Configuration\n\n1. **HTTPS**: Use HTTPS for MCP server URLs\n2. **Authentication**: Always use authentication (avoid \"none\" in production)\n3. **Token Rotation**: Rotate authentication tokens regularly\n4. **Naming**: Use descriptive names for easy identification\n\n### Agent Configuration\n\n1. **Selective Enablement**: Only enable servers that agents need\n2. **Documentation**: Document which servers are used for what\n3. **Testing**: Test MCP server integration before production use\n\n## Example Use Cases\n\n### Weather API\n\n```json\n{\n  \"name\": \"Weather API\",\n  \"url\": \"https://api.weather.example.com/mcp\",\n  \"authType\": \"header\",\n  \"config\": {\n    \"headerValue\": \"Bearer weather_api_key_123\"\n  }\n}\n```\n\nAgent can call:\n\n- `get_weather` - Get current weather\n- `get_forecast` - Get weather forecast\n\n### Database Query\n\n```json\n{\n  \"name\": \"Database API\",\n  \"url\": \"https://db-api.example.com/mcp\",\n  \"authType\": \"basic\",\n  \"config\": {\n    \"username\": \"db_user\",\n    \"password\": \"db_pass\"\n  }\n}\n```\n\nAgent can call:\n\n- `query` - Execute database query\n- `insert` - Insert data\n\n### Custom Business Logic\n\n```json\n{\n  \"name\": \"Business Logic API\",\n  \"url\": \"https://business.example.com/mcp\",\n  \"authType\": \"header\",\n  \"config\": {\n    \"headerValue\": \"Bearer business_key_123\"\n  }\n}\n```\n\nAgent can call:\n\n- `process_order` - Process customer order\n- `calculate_price` - Calculate product price\n\n### Notion Integration\n\n```json\n{\n  \"name\": \"My Notion Workspace\",\n  \"authType\": \"oauth\",\n  \"serviceType\": \"notion\",\n  \"config\": {}\n}\n```\n\n**Setup Requirements**:\n\n1. Create a Notion Public Integration:\n   - Go to [Notion Integrations](https://www.notion.com/my-integrations)\n   - Click \"+ New integration\"\n   - Select \"Public\" as the integration type\n   - Provide your company name, website, and redirect URI: `{OAUTH_REDIRECT_BASE_URL}/api/mcp/oauth/notion/callback`\n   - Copy the OAuth client ID and client secret from the \"Secrets\" tab\n\n2. Configure Environment Variables:\n   - Set `NOTION_OAUTH_CLIENT_ID` to your Notion OAuth client ID\n   - Set `NOTION_OAUTH_CLIENT_SECRET` to your Notion OAuth client secret\n   - Ensure `OAUTH_REDIRECT_BASE_URL` is set correctly\n\n3. Connect Your Notion Account:\n   - After creating the MCP server, click \"Connect\" to authorize the integration\n   - Select which pages and databases to grant access to\n   - The integration will have read, search, and write access to shared resources\n\n**Available Tools**:\n\nOnce connected, agents can use the following Notion tools:\n\n- `notion_read_{serverName}` - Read a page by ID, returns full page content and properties\n- `notion_search_{serverName}` - Search for pages, databases, and data sources\n- `notion_create_{serverName}` - Create a new page (as child of page, database, data source, or workspace)\n- `notion_update_{serverName}` - Update page properties or archive a page\n- `notion_query_database_{serverName}` - Query a database with filters and sorts\n- `notion_create_database_page_{serverName}` - Create a new page in a database\n- `notion_update_database_page_{serverName}` - Update a page in a database\n\n**Important Notes**:\n\n- Notion requires pages and databases to be explicitly shared with the integration\n- The integration uses Notion API version `2025-09-03`\n- Notion access tokens don't expire, but the integration handles token refresh for compatibility\n- Database operations require properties to match the database schema\n- Search can return pages, databases, and data sources (new in API 2025-09-03)\n\n### Linear Integration\n\n```json\n{\n  \"name\": \"My Linear Workspace\",\n  \"authType\": \"oauth\",\n  \"serviceType\": \"linear\",\n  \"config\": {}\n}\n```\n\n**Setup Requirements**:\n\n1. Create a Linear OAuth application:\n   - Go to [Linear developer settings](https://linear.app/settings/api)\n   - Create a new OAuth application\n   - Add redirect URI: `{OAUTH_REDIRECT_BASE_URL}/api/mcp/oauth/linear/callback`\n   - Copy the client ID and client secret\n\n2. Configure Environment Variables:\n   - Set `LINEAR_OAUTH_CLIENT_ID` to your Linear OAuth client ID\n   - Set `LINEAR_OAUTH_CLIENT_SECRET` to your Linear OAuth client secret\n   - Ensure `OAUTH_REDIRECT_BASE_URL` is set correctly\n\n3. Connect Your Linear Account:\n   - After creating the MCP server, click \"Connect\" to authorize the integration\n   - The integration requests read-only access via the `read` scope\n\n**Available Tools**:\n\nOnce connected, agents can use the following Linear tools:\n\n- `linear_list_teams_{serverName}` - List teams with IDs, names, and keys\n- `linear_list_projects_{serverName}` - List projects with pagination\n- `linear_list_issues_{serverName}` - List issues with optional filters (team, project, assignee, state)\n- `linear_get_issue_{serverName}` - Get issue details by issue ID\n- `linear_search_issues_{serverName}` - Search issues by query with optional filters\n\n**Important Notes**:\n\n- Linear OAuth uses app-actor authorization for MCP tools\n- Tokens are automatically refreshed when supported by the Linear OAuth app\n\n### HubSpot Integration\n\n```json\n{\n  \"name\": \"My HubSpot Account\",\n  \"authType\": \"oauth\",\n  \"serviceType\": \"hubspot\",\n  \"config\": {}\n}\n```\n\n**Setup Requirements**:\n\n1. Create a HubSpot app:\n   - Go to [HubSpot developer portal](https://developers.hubspot.com/)\n   - Create or open your app\n   - Add redirect URI: `{OAUTH_REDIRECT_BASE_URL}/api/mcp/oauth/hubspot/callback`\n   - Enable these scopes:\n     - `crm.objects.contacts.read`\n     - `crm.objects.companies.read`\n     - `crm.objects.deals.read`\n     - `crm.objects.owners.read`\n     - `oauth`\n   - Copy the client ID and client secret\n\n2. Configure Environment Variables:\n   - Set `HUBSPOT_OAUTH_CLIENT_ID` to your HubSpot OAuth client ID\n   - Set `HUBSPOT_OAUTH_CLIENT_SECRET` to your HubSpot OAuth client secret\n   - Ensure `OAUTH_REDIRECT_BASE_URL` is set correctly\n\n3. Connect Your HubSpot Account:\n   - After creating the MCP server, click \"Connect\" to authorize the integration\n   - The integration requests read-only CRM scopes for contacts, companies, deals, and owners\n\n**Available Tools**:\n\nOnce connected, agents can use the following HubSpot tools:\n\n- `hubspot_list_contacts_{serverName}` - List contacts with pagination and selected properties\n- `hubspot_get_contact_{serverName}` - Get a contact by ID\n- `hubspot_search_contacts_{serverName}` - Search contacts by query text\n- `hubspot_list_companies_{serverName}` - List companies with pagination and selected properties\n- `hubspot_get_company_{serverName}` - Get a company by ID\n- `hubspot_search_companies_{serverName}` - Search companies by query text\n- `hubspot_list_deals_{serverName}` - List deals with pagination and selected properties\n- `hubspot_get_deal_{serverName}` - Get a deal by ID\n- `hubspot_search_deals_{serverName}` - Search deals by query text\n- `hubspot_list_owners_{serverName}` - List owners with optional email filter\n- `hubspot_get_owner_{serverName}` - Get an owner by ID\n- `hubspot_search_owners_{serverName}` - Search owners by email\n\n**Important Notes**:\n\n- HubSpot OAuth tokens are refreshed automatically when expired\n- The integration is read-only; only GET/search operations are performed\n\n### Shopify Integration\n\n```json\n{\n  \"name\": \"My Shopify Store\",\n  \"authType\": \"oauth\",\n  \"serviceType\": \"shopify\",\n  \"config\": {\n    \"shopDomain\": \"my-cool-store.myshopify.com\"\n  }\n}\n```\n\n**Setup Requirements**:\n\n1. Create a Shopify app:\n   - Go to the [Shopify Partner Dashboard](https://partners.shopify.com/)\n   - Create or open your app\n   - Add redirect URI: `{OAUTH_REDIRECT_BASE_URL}/api/mcp/oauth/shopify/callback`\n   - Enable scopes:\n     - `read_orders`\n     - `read_products`\n     - `read_customers`\n   - Copy the client ID and client secret\n\n2. Configure Environment Variables:\n   - Set `SHOPIFY_OAUTH_CLIENT_ID` to your Shopify OAuth client ID\n   - Set `SHOPIFY_OAUTH_CLIENT_SECRET` to your Shopify OAuth client secret\n   - Ensure `OAUTH_REDIRECT_BASE_URL` is set correctly\n\n3. Configure the MCP Server:\n   - Provide your shop domain (e.g., `my-cool-store.myshopify.com`)\n   - After creating the MCP server, click \"Connect\" to authorize the integration\n\n**Available Tools**:\n\nOnce connected, agents can use the following Shopify tools:\n\n- `shopify_get_order_{serverName}` - Find an order by ID or number (e.g., #1001)\n- `shopify_search_products_{serverName}` - Search products by title for inventory and pricing\n- `shopify_sales_report_{serverName}` - Summarize order counts and gross sales by date range\n\n**Important Notes**:\n\n- Shopify uses offline access tokens so agents can work in the background\n- Product inventory lives on each product's `variants` array (`inventory_quantity`)\n\n### Salesforce Integration\n\n```json\n{\n  \"name\": \"My Salesforce Org\",\n  \"authType\": \"oauth\",\n  \"serviceType\": \"salesforce\",\n  \"config\": {}\n}\n```\n\n**Setup Requirements**:\n\n1. Create a Salesforce Connected App:\n   - Go to Salesforce Setup → App Manager\n   - Create or open a Connected App\n   - Enable OAuth Settings\n   - Add redirect URI: `{OAUTH_REDIRECT_BASE_URL}/api/mcp/oauth/salesforce/callback`\n   - Add OAuth scopes:\n     - `api`\n     - `refresh_token`\n     - `offline_access`\n   - Save and copy the Consumer Key and Consumer Secret\n\n2. Configure Environment Variables:\n   - Set `SALESFORCE_OAUTH_CLIENT_ID` to your Salesforce Consumer Key\n   - Set `SALESFORCE_OAUTH_CLIENT_SECRET` to your Salesforce Consumer Secret\n   - Ensure `OAUTH_REDIRECT_BASE_URL` is set correctly\n\n3. Connect Your Salesforce Account:\n   - After creating the MCP server, click \"Connect\" to authorize the integration\n\n**Available Tools**:\n\nOnce connected, agents can use the following Salesforce tools:\n\n- `salesforce_list_objects_{serverName}` - List standard and custom objects in the org\n- `salesforce_describe_object_{serverName}` - Describe fields and relationships for an object\n- `salesforce_query_{serverName}` - Execute SOQL queries (read-only)\n\n**Important Notes**:\n\n- Salesforce returns an `instance_url` during token exchange, and all API calls must use that instance URL (not `login.salesforce.com`)\n- The integration follows a discovery-first workflow: list objects → describe object → query\n- The tools are read-only; only GET requests are performed\n\n### Slack Integration\n\n```json\n{\n  \"name\": \"My Slack Workspace\",\n  \"authType\": \"oauth\",\n  \"serviceType\": \"slack\",\n  \"config\": {}\n}\n```\n\n**Setup Requirements**:\n\n1. Create a Slack app:\n   - Go to [Slack API apps](https://api.slack.com/apps)\n   - Create or open your Slack app\n   - Add redirect URI: `{OAUTH_REDIRECT_BASE_URL}/api/mcp/oauth/slack/callback`\n   - Add these Bot Token Scopes:\n     - `channels:read`\n     - `channels:history`\n     - `groups:read`\n     - `groups:history`\n     - `chat:write`\n   - Copy the client ID and client secret\n\n2. Configure Environment Variables:\n   - Set `SLACK_OAUTH_CLIENT_ID` to your Slack OAuth client ID\n   - Set `SLACK_OAUTH_CLIENT_SECRET` to your Slack OAuth client secret\n   - Ensure `OAUTH_REDIRECT_BASE_URL` is set correctly\n\n3. Connect Your Slack Account:\n   - After creating the MCP server, click \"Connect\" to authorize the integration\n   - The integration uses bot tokens to access channels\n\n**Available Tools**:\n\nOnce connected, agents can use the following Slack tools:\n\n- `slack_list_channels_{serverName}` - List public/private channels with IDs and metadata\n- `slack_get_channel_history_{serverName}` - Read recent messages from a channel (plain text)\n- `slack_post_message_{serverName}` - Post a message to a channel\n\n**Important Notes**:\n\n- The Slack app must be installed in the workspace and invited to private channels to read them\n- Message history is returned as plain text to reduce token usage\n\n### Intercom Integration\n\n```json\n{\n  \"name\": \"My Intercom Workspace\",\n  \"authType\": \"oauth\",\n  \"serviceType\": \"intercom\",\n  \"config\": {}\n}\n```\n\n**Setup Requirements**:\n\n1. Create an Intercom app:\n   - Go to the Intercom Developer Hub and open your app\n   - Enable OAuth and add redirect URI: `{OAUTH_REDIRECT_BASE_URL}/api/mcp/oauth/intercom/callback`\n   - Enable the scopes:\n     - `read_conversations`\n     - `write_conversations`\n     - `read_users`\n     - `write_users`\n     - `read_admins`\n   - Copy the client ID and client secret\n\n2. Configure Environment Variables:\n   - Set `INTERCOM_OAUTH_CLIENT_ID` to your Intercom OAuth client ID\n   - Set `INTERCOM_OAUTH_CLIENT_SECRET` to your Intercom OAuth client secret\n   - Ensure `OAUTH_REDIRECT_BASE_URL` is set correctly\n\n3. Connect Your Intercom Account:\n   - After creating the MCP server, click \"Connect\" to authorize the integration\n   - Use an Intercom admin account to ensure replies are sent as an admin\n\n**Available Tools**:\n\nOnce connected, agents can use the following Intercom tools:\n\n- `intercom_list_contacts_{serverName}` - List contacts with pagination\n- `intercom_get_contact_{serverName}` - Get a contact by ID\n- `intercom_search_contacts_{serverName}` - Search contacts using Intercom search queries\n- `intercom_update_contact_{serverName}` - Update a contact by ID\n- `intercom_list_conversations_{serverName}` - List conversations with pagination\n- `intercom_get_conversation_{serverName}` - Get a conversation by ID\n- `intercom_search_conversations_{serverName}` - Search conversations using Intercom search queries\n- `intercom_reply_conversation_{serverName}` - Reply to or update conversations as an admin\n\n**Search Query Format**:\n\nIntercom search tools (`intercom_search_contacts_*`, `intercom_search_conversations_*`) require a query object, not a plain string. Example email search:\n\n```json\n{\n  \"query\": {\n    \"operator\": \"AND\",\n    \"value\": [\n      {\n        \"field\": \"email\",\n        \"operator\": \"=\",\n        \"value\": \"email@projectmap.com\"\n      }\n    ]\n  }\n}\n```\n\n**Shortcut Inputs**:\n\nYou can also provide shortcut parameters instead of a full query object:\n\n- `intercom_search_contacts_*`: `email`, `name`, `externalId`\n- `intercom_search_conversations_*`: `conversationId`, `contactId` or `contactIds`, `state`, `createdAfter`, `updatedAfter`\n\nIf `query` is provided, shortcuts are ignored.\n\n**Common Pitfalls**:\n\n- `contact_id` and `q` are not valid Intercom search fields. Use `contactId` as a shortcut or `contact_ids` in the query object.\n\n**Important Notes**:\n\n- Intercom OAuth does not provide refresh tokens; reconnect if the token is revoked\n- Replies are sent using the admin account that completed OAuth\n\n### Todoist Integration\n\n```json\n{\n  \"name\": \"My Todoist Workspace\",\n  \"authType\": \"oauth\",\n  \"serviceType\": \"todoist\",\n  \"config\": {}\n}\n```\n\n**Setup Requirements**:\n\n1. Create a Todoist OAuth app:\n   - Go to [Todoist App Management](https://developer.todoist.com/appconsole.html)\n   - Create or open your OAuth application\n   - Add redirect URI: `{OAUTH_REDIRECT_BASE_URL}/api/mcp/oauth/todoist/callback`\n   - Enable scopes: `tasks:read`, `tasks:write`, `projects:read`\n   - Copy the client ID and client secret\n\n2. Configure Environment Variables:\n   - Set `TODOIST_OAUTH_CLIENT_ID` to your Todoist OAuth client ID\n   - Set `TODOIST_OAUTH_CLIENT_SECRET` to your Todoist OAuth client secret\n   - Ensure `OAUTH_REDIRECT_BASE_URL` is set correctly\n\n3. Connect Your Todoist Account:\n   - After creating the MCP server, click \"Connect\" to authorize the integration\n\n**Available Tools**:\n\nOnce connected, agents can use the following Todoist tools:\n\n- `todoist_add_task_{serverName}` - Create a task with natural language due dates\n- `todoist_get_tasks_{serverName}` - List active tasks using Todoist filters\n- `todoist_close_task_{serverName}` - Complete a task by ID\n- `todoist_get_projects_{serverName}` - List projects to resolve project IDs\n\n**Important Notes**:\n\n- Todoist OAuth does not provide refresh tokens; reconnect if the token is revoked\n\n### Zendesk Integration\n\n```json\n{\n  \"name\": \"My Zendesk Workspace\",\n  \"authType\": \"oauth\",\n  \"serviceType\": \"zendesk\",\n  \"config\": {\n    \"subdomain\": \"yourcompany\",\n    \"clientId\": \"zendesk_client_id\",\n    \"clientSecret\": \"zendesk_client_secret\"\n  }\n}\n```\n\n**Setup Requirements**:\n\n1. Create a Zendesk OAuth client:\n   - Go to Zendesk Admin Center → Apps and integrations → APIs → Zendesk API\n   - Create an OAuth client\n   - Add redirect URI: `{OAUTH_REDIRECT_BASE_URL}/api/mcp/oauth/zendesk/callback`\n   - Enable the scopes:\n     - `tickets:read`\n     - `tickets:write`\n    - `hc:read`\n   - Copy the **Unique identifier** (not the numeric client ID) and client secret\n\n2. Configure the MCP Server:\n   - Provide your Zendesk subdomain and OAuth client credentials in the MCP server form\n   - The subdomain is the `yourcompany` portion of `https://yourcompany.zendesk.com`\n\n3. Connect Your Zendesk Account:\n   - After creating the MCP server, click \"Connect\" to authorize the integration\n\n**Available Tools**:\n\nOnce connected, agents can use the following Zendesk tools:\n\n- `zendesk_search_tickets_{serverName}` - Search tickets using Zendesk query syntax\n- `zendesk_get_ticket_details_{serverName}` - Retrieve full ticket comment history\n- `zendesk_draft_comment_{serverName}` - Add a private internal note (draft reply)\n- `zendesk_search_help_center_{serverName}` - Search Help Center articles\n\n**Important Notes**:\n\n- The draft comment tool always creates private notes (`public: false`)\n- Use Zendesk query syntax such as `type:ticket status:open requester:alice@example.com`\n\n### Stripe Integration\n\n```json\n{\n  \"name\": \"My Stripe Account\",\n  \"authType\": \"oauth\",\n  \"serviceType\": \"stripe\",\n  \"config\": {}\n}\n```\n\n**Setup Requirements**:\n\n1. Create a Stripe Connect application:\n   - Go to [Stripe Connect settings](https://dashboard.stripe.com/settings/connect)\n   - Set redirect URI: `{OAUTH_REDIRECT_BASE_URL}/api/mcp/oauth/stripe/callback`\n   - Copy the client ID and client secret\n\n2. Configure Environment Variables:\n   - Set `STRIPE_OAUTH_CLIENT_ID` to your Stripe OAuth client ID\n   - Set `STRIPE_OAUTH_CLIENT_SECRET` to your Stripe OAuth client secret\n   - Ensure `OAUTH_REDIRECT_BASE_URL` is set correctly\n\n3. Connect Your Stripe Account:\n   - After creating the MCP server, click \"Connect\" to authorize the integration\n   - The integration requests read-only access via Stripe's `read_only` scope\n\n**Available Tools**:\n\nOnce connected, agents can use the following Stripe tools:\n\n- `stripe_search_charges_{serverName}` - Search charges by Stripe query string and/or email\n- `stripe_get_metrics_{serverName}` - Retrieve balance and refunds within a required date range\n\n**Important Notes**:\n\n- Stripe OAuth tokens are refreshed automatically when expired\n- The integration is read-only; no write operations are performed\n\n## Troubleshooting\n\n### Server Not Found\n\n- Verify server ID is correct\n- Check server belongs to the workspace\n- Ensure server is not deleted\n\n### Authentication Errors\n\n- Verify authentication type matches server configuration\n- Check credentials are correct\n- Verify header format (if using header auth)\n\n### Connection Errors\n\n- Check MCP server URL is accessible\n- Verify network connectivity\n- Check firewall rules\n\n### Timeout Errors\n\n- Increase timeout if needed (currently 30 seconds)\n- Optimize MCP server response time\n- Check server performance\n\n### Tool Not Available\n\n- Verify MCP server is enabled for the agent\n- Check `enabledMcpServerIds` includes the server ID\n- Verify agent configuration is saved\n\n## API Reference\n\nSee [API Reference](./api-reference.md) for complete endpoint documentation.\n",
  "credit-system": "# Credit System\n\nThis document explains how the credit system works in Helpmaton, including credit reservation, adjustment, spending limits, and BYOK (Bring Your Own Key) support.\n\n## Overview\n\nHelpmaton uses a credit-based billing system where workspaces have credit balances that are deducted when agents make LLM API calls. Credits are reserved before calls and adjusted after calls based on actual token usage.\n\n## Key Concepts\n\n### Credit Balance\n\n- Each workspace has a `creditBalance` field stored in the `workspace` table\n- Credits are denominated in USD\n- Credits can be added via trial credit requests or future payment methods\n- Credits are deducted atomically to prevent race conditions\n\n### Credit Reservation\n\nBefore making an LLM API call, the system:\n\n1. Estimates the cost based on message length and model pricing\n2. Atomically reserves credits by deducting the estimated amount\n3. Creates a reservation record with a 15-minute TTL\n4. Proceeds with the LLM call\n\n### Credit Adjustment\n\nAfter the LLM API call completes:\n\n1. Calculates actual cost from token usage\n2. Compares actual cost to reserved amount\n3. Refunds difference if actual < reserved\n4. Charges additional amount if actual > reserved\n5. Cleans up the reservation record\n\n### BYOK (Bring Your Own Key)\n\nWhen a workspace has a workspace API key configured, requests can use the workspace's own LLM API key instead of Helpmaton's key. In this case:\n\n- Credit reservation is skipped\n- Credit adjustment is skipped\n- The workspace pays directly to the LLM provider\n- Token usage is still tracked for analytics\n- Background embedding generation (SQS queue) follows the same rule: system key usage is billed to the workspace, BYOK usage skips credit charges.\n\n## Credit Reservation Flow\n\n```\nRequest arrives\n    │\n    ▼\nEstimate token cost\n    │\n    ├─ Count tokens in messages\n    ├─ Count tokens in system prompt\n    ├─ Estimate tool definitions tokens\n    └─ Apply model pricing\n    │\n    ▼\nCheck credit balance\n    │\n    ├─ Insufficient → InsufficientCreditsError\n    └─ Sufficient → Continue\n    │\n    ▼\nAtomically reserve credits\n    │\n    ├─ DynamoDB atomicUpdate\n    ├─ Deduct estimated cost\n    ├─ Create reservation record\n    └─ Return reservation ID\n    │\n    ▼\nProceed with LLM call\n```\n\n### Atomic Reservation\n\nCredit reservation uses DynamoDB's `atomicUpdate` to ensure thread-safety:\n\n```typescript\nawait db.workspace.atomicUpdate(\n  workspacePk,\n  \"workspace\",\n  async (current) => {\n    if (current.creditBalance < estimatedCost) {\n      throw new InsufficientCreditsError(...);\n    }\n    return {\n      pk: workspacePk,\n      sk: \"workspace\",\n      creditBalance: current.creditBalance - estimatedCost,\n    };\n  },\n  { maxRetries: 3 }\n);\n```\n\nThis ensures that:\n\n- Multiple concurrent requests don't over-deduct credits\n- Credit balance is always accurate\n- Race conditions are prevented\n\n### Reservation Record\n\nA reservation record is created in the `credit-reservations` table:\n\n- `pk`: `credit-reservations/{reservationId}`\n- `workspaceId`: Workspace ID\n- `reservedAmount`: Estimated cost that was reserved\n- `estimatedCost`: Same as reservedAmount (for reference)\n- `currency`: Workspace currency\n- `expires`: TTL timestamp (15 minutes from creation)\n- `expiresHour`: Hour bucket for GSI queries\n\nThe reservation record:\n\n- Tracks which credits are \"in flight\"\n- Enables cleanup of expired reservations\n- Allows credit adjustment after LLM call\n\n## Credit Adjustment Flow\n\n```\nLLM call completes\n    │\n    ▼\nExtract token usage\n    │\n    ├─ promptTokens (input)\n    ├─ completionTokens (output)\n    └─ reasoningTokens (optional)\n    │\n    ▼\nCalculate actual cost\n    │\n    ├─ Apply model pricing\n    ├─ Handle tiered pricing if applicable\n    └─ Convert to workspace currency\n    │\n    ▼\nGet reservation record\n    │\n    ├─ Not found → Assume already processed\n    └─ Found → Continue\n    │\n    ▼\nCompare actual vs reserved\n    │\n    ├─ actual < reserved → Refund difference\n    ├─ actual > reserved → Charge additional\n    └─ actual = reserved → No change\n    │\n    ▼\nAtomically adjust credits\n    │\n    ├─ DynamoDB atomicUpdate\n    ├─ Update credit balance\n    └─ Return updated workspace\n    │\n    ▼\nReservation cleanup\n    │\n    └─ TTL automatically deletes after 15 minutes\n```\n\n### Adjustment Calculation\n\n```typescript\nconst actualCost = calculateTokenCost(\n  provider,\n  modelName,\n  tokenUsage.promptTokens,\n  tokenUsage.completionTokens,\n  currency,\n  tokenUsage.reasoningTokens\n);\n\nconst difference = actualCost - reservedAmount;\n\n// Refund if actual < reserved\nif (difference < 0) {\n  newBalance = currentBalance + Math.abs(difference);\n}\n// Charge additional if actual > reserved\nelse if (difference > 0) {\n  newBalance = currentBalance - difference;\n}\n```\n\n### Handling Missing Reservations\n\nIf a reservation record is not found during adjustment:\n\n- The reservation may have already been cleaned up (expired)\n- Or the reservation was never created (BYOK, error before reservation)\n- The system logs a warning and returns the workspace without adjustment\n- This is safe because credits were either never reserved or already adjusted\n\n## Spending Limits\n\nSpending limits provide an additional layer of control beyond credit balances. Limits can be set at both workspace and agent levels.\n\n### Limit Types\n\n- **Daily**: Rolling 24-hour window\n- **Weekly**: Rolling 7-day window\n- **Monthly**: Rolling 30-day window\n\n### Limit Structure\n\n```typescript\n{\n  timeFrame: \"daily\" | \"weekly\" | \"monthly\",\n  amount: number  // Maximum spending in workspace currency\n}\n```\n\n### Limit Checking\n\nBefore reserving credits, the system checks all applicable limits:\n\n1. **Workspace Limits**: Check all workspace-level limits\n2. **Agent Limits**: If agent is specified, check all agent-level limits\n3. **Rolling Window**: Calculate spending in the rolling window\n4. **Estimate Check**: Check if estimated cost + current spending would exceed limit\n\nIf any limit would be exceeded, a `SpendingLimitExceededError` is thrown.\n\n### Spending Calculation\n\nSpending is calculated from `token-usage-aggregates` table:\n\n```typescript\n// Get aggregates for the rolling window\nconst startDate = calculateRollingWindow(timeFrame); // e.g., 24 hours ago\nconst aggregates = await queryAggregates(\n  workspaceId,\n  agentId, // optional\n  startDate,\n  now\n);\n\n// Sum costs\nconst currentSpending = aggregates.reduce(\n  (sum, agg) => sum + agg.costUsd,\n  0\n);\n```\n\n### Limit Enforcement\n\nLimits are checked in `validateCreditsAndLimits()` before credit reservation:\n\n```typescript\n// Check spending limits\nconst limitCheck = await checkSpendingLimits(\n  db,\n  workspace,\n  agent,\n  estimatedCost\n);\n\nif (!limitCheck.passed) {\n  throw new SpendingLimitExceededError(limitCheck.failedLimits);\n}\n```\n\nFailed limits include:\n\n- `scope`: \"workspace\" or \"agent\"\n- `timeFrame`: \"daily\", \"weekly\", or \"monthly\"\n- `limit`: Maximum allowed amount\n- `current`: Current spending + estimated cost\n\n## BYOK (Bring Your Own Key)\n\nWhen a workspace has an OpenRouter API key configured, requests can use the workspace's own OpenRouter API key instead of Helpmaton's key. Only OpenRouter keys are supported for BYOK.\n\n### How It Works\n\n1. **Workspace API Key**: Stored in `workspace-api-key` table, encrypted at rest (only OpenRouter keys are supported)\n2. **Request Detection**: Handler checks if workspace has OpenRouter API key configured\n3. **Key Usage**: If present, use workspace's OpenRouter key for LLM and embedding API calls\n4. **Credit Skipping**: Skip credit reservation and adjustment (no deduction from workspace credits)\n5. **Spending Limits**: Spending rate limits are still checked and applied (costs are tracked in aggregates)\n6. **Cost Tracking**: Costs are calculated and stored in conversation records and aggregates for spending limit enforcement\n\n### Benefits\n\n- Workspaces can use their own OpenRouter API keys\n- Direct billing from OpenRouter\n- No credit balance required\n- Spending rate limits still enforced\n- Token usage and costs tracked for analytics and limit enforcement\n\n### Implementation\n\n```typescript\n// Check if workspace has OpenRouter API key\nconst workspaceApiKey = await db[\"workspace-api-key\"].get(\n  `workspace-api-keys/${workspaceId}/openrouter`,\n  \"key\"\n);\n\nconst usesByok = !!workspaceApiKey;\n\n// Skip credit reservation if BYOK, but still check spending limits\nif (usesByok) {\n  return {\n    reservationId: \"byok\",\n    reservedAmount: 0,\n    workspace,\n  };\n}\n```\n\n## Currency Support\n\nCredits are stored in USD (United States Dollar).\n\n### Cost Calculation\n\nToken costs are calculated in USD:\n\n```typescript\nconst cost = calculateTokenCost(\n  provider,\n  modelName,\n  inputTokens,\n  outputTokens,\n  reasoningTokens\n);\n```\n\nPricing is stored in `apps/backend/src/config/pricing.json` with USD rates only.\n\n## Error Handling\n\n### InsufficientCreditsError\n\nThrown when credit balance is insufficient for estimated cost:\n\n```typescript\n{\n  message: \"Insufficient credits\",\n  workspaceId: string,\n  required: number,\n  available: number,\n  currency: \"usd\"\n}\n```\n\n### SpendingLimitExceededError\n\nThrown when spending limit would be exceeded:\n\n```typescript\n{\n  message: \"Spending limit exceeded\",\n  failedLimits: Array<{\n    scope: \"workspace\" | \"agent\",\n    timeFrame: \"daily\" | \"weekly\" | \"monthly\",\n    limit: number,\n    current: number\n  }>\n}\n```\n\n### CreditDeductionError\n\nThrown when credit adjustment fails (rare):\n\n```typescript\n{\n  message: \"Failed to adjust credit reservation\",\n  reservationId: string,\n  workspaceId: string\n}\n```\n\n## Cleanup and Expiration\n\n### Reservation Cleanup\n\nReservations are automatically cleaned up via TTL:\n\n- TTL set to 15 minutes from creation\n- DynamoDB automatically deletes expired records\n- Scheduled function also cleans up expired reservations (backup)\n\n### Scheduled Cleanup\n\nA scheduled function runs every 10 minutes to clean up expired reservations:\n\n```typescript\n// Query reservations expiring in current hour\nconst expiresHour = calculateExpiresHourBucket(now);\nconst reservations = await db[\"credit-reservations\"].query({\n  IndexName: \"byExpiresHour\",\n  KeyConditionExpression: \"expiresHour = :hour\",\n  FilterExpression: \"expires < :now\",\n  ExpressionAttributeValues: {\n    \":hour\": expiresHour,\n    \":now\": Math.floor(Date.now() / 1000),\n  },\n});\n\n// Reservations are automatically deleted by TTL\n// This is a backup cleanup mechanism\n```\n\n## Feature Flags\n\nCredit validation and spending limit checks can be disabled via environment variables:\n\n- `ENABLE_CREDIT_VALIDATION`: Enable/disable credit validation (default: true)\n- `ENABLE_SPENDING_LIMIT_CHECKS`: Enable/disable spending limit checks (default: true)\n\nThese flags are useful during deployment or testing to temporarily disable checks.\n\n## Best Practices\n\n1. **Always reserve before LLM calls**: Prevents over-spending\n2. **Adjust after calls**: Ensures accurate billing\n3. **Handle errors gracefully**: Return clear error messages to users\n4. **Monitor credit balances**: Alert users when balances are low\n5. **Set spending limits**: Prevent unexpected costs\n6. **Use BYOK for high-volume**: Reduce credit management overhead\n\n## API Endpoints\n\n### Get Workspace Credits\n\n```\nGET /api/workspaces/:workspaceId\n```\n\nReturns workspace including `creditBalance` and `currency`.\n\n### Add Credits (Admin)\n\nCredits are added via trial credit requests or future payment integration.\n\n### Set Spending Limits\n\n```\nPOST /api/workspaces/:workspaceId/spending-limits\nBody: { timeFrame: \"daily\" | \"weekly\" | \"monthly\", amount: number }\n```\n\n```\nPOST /api/workspaces/:workspaceId/agents/:agentId/spending-limits\nBody: { timeFrame: \"daily\" | \"weekly\" | \"monthly\", amount: number }\n```\n\n### Update Spending Limits\n\n```\nPUT /api/workspaces/:workspaceId/spending-limits/:timeFrame\nBody: { amount: number }\n```\n\n```\nPUT /api/workspaces/:workspaceId/agents/:agentId/spending-limits/:timeFrame\nBody: { amount: number }\n```\n\n### Delete Spending Limits\n\n```\nDELETE /api/workspaces/:workspaceId/spending-limits/:timeFrame\n```\n\n```\nDELETE /api/workspaces/:workspaceId/agents/:agentId/spending-limits/:timeFrame\n```\n\n## Monitoring\n\n### Credit Balance Monitoring\n\n- Check `workspace.creditBalance` regularly\n- Alert when balance is low\n- Track credit consumption trends\n\n### Spending Limit Monitoring\n\n- Track spending against limits\n- Alert when approaching limits\n- Provide spending dashboards\n\n### Reservation Monitoring\n\n- Monitor reservation creation/cleanup\n- Track reservation expiration\n- Alert on stuck reservations\n\n## Troubleshooting\n\n### Credits Not Deducted\n\n- Check if BYOK is enabled (skips deduction)\n- Verify credit validation is enabled\n- Check reservation records\n- Review error logs\n\n### Spending Limits Not Working\n\n- Verify spending limit checks are enabled\n- Check limit configuration\n- Review aggregate data\n- Verify rolling window calculation\n\n### Reservation Cleanup Issues\n\n- Check TTL configuration\n- Verify scheduled function is running\n- Review reservation expiration times\n- Check DynamoDB TTL status\n",
  "webhook-system": "# Webhook System\n\nThis document describes the webhook system in Helpmaton, including endpoint structure, authentication, request/response formats, and error handling.\n\n## Overview\n\nWebhooks allow external applications to send messages to Helpmaton agents. Each agent has one or more API keys that authenticate webhook requests. Requests are processed asynchronously, so the HTTP response acknowledges receipt and includes a conversation ID for tracking.\n\n## Endpoint Structure\n\n### Webhook URL Format\n\n```\nPOST /api/webhook/:workspaceId/:agentId/:key\n```\n\n**Path Parameters**:\n\n- `workspaceId` (String): Workspace ID containing the agent\n- `agentId` (String): Agent ID to send message to\n- `key` (String): Agent API key for authentication\n\n**Example**:\n\n```\nPOST https://app.helpmaton.com/api/webhook/ws_123/agent_456/key_789\n```\n\n## Authentication\n\n### Webhooks\n\nEach agent can have multiple webhooks for sending messages:\n\n- Webhook keys are generated as UUIDs when created\n- Keys are stored in the `agent-key` table, encrypted at rest\n- Webhooks can be named for easy identification\n- Webhooks can be deleted if compromised\n\n### Key Validation\n\nWhen a webhook request arrives:\n\n1. Extract `workspaceId`, `agentId`, and `key` from path parameters\n2. Query `agent-key` table using GSI `byAgentId`\n3. Find matching key where:\n   - `agentId` matches\n   - `key` value matches\n   - `workspaceId` matches\n4. If no match found, return `401 Unauthorized`\n\n### Key Management\n\n**Create Webhook**:\n\n```\nPOST /api/workspaces/:workspaceId/agents/:agentId/keys\nBody: { name?: string, provider?: \"google\" }\n```\n\n**List Webhooks**:\n\n```\nGET /api/workspaces/:workspaceId/agents/:agentId/keys\n```\n\n**Delete Webhook**:\n\n```\nDELETE /api/workspaces/:workspaceId/agents/:agentId/keys/:keyId\n```\n\n## Request Format\n\n### HTTP Method\n\n- **Method**: `POST`\n- **Content-Type**: `text/plain` or `application/json`\n\n### Request Body\n\nThe request body contains the message to send to the agent:\n\n**Plain Text**:\n\n```\nHello, how can you help me?\n```\n\n**JSON** (optional):\n\n```json\n{\n  \"message\": \"Hello, how can you help me?\"\n}\n```\n\nThe webhook handler accepts both formats:\n\n- Plain text is used directly as the message\n- JSON is parsed and the `message` field is extracted\n\n### Request Headers\n\nStandard HTTP headers are accepted:\n\n- `Content-Type`: `text/plain` or `application/json`\n- `User-Agent`: Client identifier (optional)\n- `X-Request-ID`: Request tracking ID (optional)\n\n## Response Format\n\n### Success Response\n\n**Status Code**: `202 Accepted`\n\n**Response Body**:\n\n```json\n{\n  \"conversationId\": \"conv_123\"\n}\n```\n\n**Fields**:\n\n- `conversationId` (String): Unique conversation ID for tracking\n\n**Notes**:\n\n- Webhook processing is asynchronous. The HTTP response does not include the assistant response.\n- There is currently no webhook status polling endpoint. Use the conversation ID for internal tracking/support, or check the workspace conversations in the UI.\n\n### Tool Calls\n\nTool calls and results are recorded in the conversation log after processing completes.\n\n### Error Responses\n\n**400 Bad Request**:\n\n```json\n{\n  \"error\": \"Invalid request format\"\n}\n```\n\n**401 Unauthorized**:\n\n```json\n{\n  \"error\": \"Invalid webhook key\"\n}\n```\n\n**403 Forbidden**:\n\n```json\n{\n  \"error\": \"Free plan has expired. Please upgrade your subscription.\"\n}\n```\n\n**429 Too Many Requests**:\n\n```json\n{\n  \"error\": \"Rate limit exceeded\"\n}\n```\n\n**Credit/Spending Errors**:\n\nIf the workspace lacks sufficient credits or exceeds spending limits, the webhook task fails during async processing. These errors are recorded in the conversation log and surfaced in the UI, but are not returned in the initial HTTP response.\n\n**500 Internal Server Error**:\n\n```json\n{\n  \"error\": \"Internal server error\"\n}\n```\n\n## Request Processing Flow\n\n```\nWebhook request arrives\n    │\n    ▼\nValidate request format\n    │\n    ├─ Extract path parameters\n    ├─ Validate HTTP method (POST)\n    └─ Extract body text\n    │\n    ▼\nValidate webhook key\n    │\n    ├─ Query agent-key table\n    ├─ Match key value\n    └─ Verify workspace/agent match\n    │\n    ├─ Invalid → 401 Unauthorized\n    └─ Valid → Continue\n    │\n    ▼\nCheck subscription limits\n    │\n    ├─ Check free plan expiration\n    ├─ Check daily request limit\n    └─ Verify subscription active\n    │\n    ├─ Expired/Limited → Error\n    └─ OK → Continue\n    │\n    ▼\nSetup agent and tools\n    │\n    ├─ Load agent configuration\n    ├─ Load workspace documents\n    ├─ Setup MCP server tools\n    └─ Configure model options\n    │\n    ▼\nValidate credits and limits\n    │\n    ├─ Estimate token cost\n    ├─ Check credit balance\n    ├─ Check spending limits\n    └─ Reserve credits (atomic)\n    │\n    ├─ Insufficient → 402 Payment Required\n    └─ OK → Continue\n    │\n    ▼\nCall LLM API\n    │\n    ├─ Generate response\n    ├─ Execute tool calls (if any)\n    └─ Get token usage\n    │\n    ▼\nAdjust credit reservation\n    │\n    ├─ Calculate actual cost\n    ├─ Compare to reserved amount\n    └─ Refund or charge difference\n    │\n    ▼\nLog conversation\n    │\n    ├─ Create conversation record\n    ├─ Store messages\n    └─ Track token usage\n    │\n    ▼\nReturn response\n    │\n    └─ Format JSON response\n```\n\n## Bot Integrations (Slack & Discord)\n\nHelpmaton supports connecting agents to Slack and Discord bots, allowing team members and community members to interact with your agents directly in those platforms.\n\n### Slack Integration\n\nSlack bots can be connected to agents using the Slack App Manifest method. The integration handles:\n- Event subscriptions (app_mentions, messages)\n- Signature verification using signing secrets\n- Throttled message updates (1.5s interval) to simulate streaming\n- Markdown to Slack formatting conversion\n\nFor detailed setup instructions, see [Slack Integration Guide](../docs/slack-integration.md).\n\n### Discord Integration\n\nDiscord bots can be connected to agents using the Interactions Endpoint method. The integration handles:\n- Interaction events (slash commands, mentions)\n- Ed25519 signature verification using public keys\n- Throttled message updates (1.5s interval) to simulate streaming\n- Markdown to Discord formatting conversion\n\nFor detailed setup instructions, see [Discord Integration Guide](../docs/discord-integration.md).\n\n### Integration Management\n\nIntegrations are managed through the REST API:\n\n- `POST /api/workspaces/:workspaceId/integrations` - Create integration\n- `GET /api/workspaces/:workspaceId/integrations` - List integrations\n- `GET /api/workspaces/:workspaceId/integrations/:integrationId` - Get integration\n- `PATCH /api/workspaces/:workspaceId/integrations/:integrationId` - Update integration\n- `DELETE /api/workspaces/:workspaceId/integrations/:integrationId` - Delete integration\n- `POST /api/workspaces/:workspaceId/integrations/slack/manifest` - Generate Slack manifest\n\nAll integration credentials (bot tokens, signing secrets, public keys) are encrypted at rest in the `bot-integration` table.\n\n## Rate Limiting\n\nWebhook requests are subject to rate limiting based on subscription plan:\n\n- **Free**: 100 requests/second, 200 burst\n- **Starter**: 500 requests/second, 1000 burst\n- **Pro**: 2000 requests/second, 4000 burst\n\nRate limiting is enforced at the API Gateway level using usage plans. See [API Throttling](./api-throttling.md) for details.\n\n## Daily Request Limits\n\nIn addition to rate limiting, there are daily request limits per subscription:\n\n- Limits are checked before each LLM call\n- Limits are tracked in hourly buckets\n- Exceeding the limit returns `429 Too Many Requests`\n\n## Credit Management\n\nEach webhook request:\n\n1. Estimates token cost before the LLM call\n2. Atomically reserves credits\n3. Makes the LLM API call\n4. Adjusts credits based on actual usage\n\nSee [Credit System](./credit-system.md) for detailed information.\n\n## Conversation Tracking\n\nWebhook requests create conversation records in the `agent-conversations` table:\n\n- `conversationId`: Unique ID for tracking\n- `conversationType`: \"webhook\"\n- `messages`: Array of all messages\n- `toolCalls`: Array of tool calls\n- `toolResults`: Array of tool results\n- `tokenUsage`: Aggregated token usage\n- `cost`: Cost in USD\n\nConversations expire after a TTL period (automatic cleanup).\n\n## Tool Support\n\nWebhooks support the same tools as other agent endpoints:\n\n- **Document Search**: Search workspace documents using semantic search\n- **MCP Server Tools**: Tools created from configured MCP servers\n- **Agent Delegation**: Agents can call other agents (if configured)\n- **Client Tools**: User-defined client-side tools\n\nTool calls are included in the response for transparency.\n\n## Error Handling\n\n### Validation Errors\n\n- **Invalid path parameters**: `400 Bad Request`\n- **Invalid HTTP method**: `400 Bad Request`\n- **Invalid request body**: `400 Bad Request`\n\n### Authentication Errors\n\n- **Invalid webhook key**: `401 Unauthorized`\n- **Key not found**: `401 Unauthorized`\n- **Workspace/agent mismatch**: `401 Unauthorized`\n\n### Business Logic Errors\n\n- **Insufficient credits**: `402 Payment Required`\n- **Free plan expired**: `403 Forbidden`\n- **Rate limit exceeded**: `429 Too Many Requests`\n- **Daily limit exceeded**: `429 Too Many Requests`\n- **Spending limit exceeded**: `402 Payment Required`\n\n### Server Errors\n\n- **LLM API error**: `500 Internal Server Error`\n- **Database error**: `500 Internal Server Error`\n- **Unexpected error**: `500 Internal Server Error`\n\n## Best Practices\n\n### Security\n\n1. **Keep keys secret**: Never commit keys to version control\n2. **Rotate keys regularly**: Delete and recreate keys periodically\n3. **Use HTTPS**: Always use HTTPS for webhook requests\n4. **Validate responses**: Verify response format and content\n\n### Performance\n\n1. **Handle timeouts**: Webhook requests have a 60-second timeout\n2. **Retry logic**: Implement exponential backoff for retries\n3. **Rate limiting**: Respect rate limits and handle 429 responses\n4. **Async processing**: Consider streaming endpoints for long responses\n\n### Error Handling\n\n1. **Check status codes**: Handle all HTTP status codes\n2. **Parse error messages**: Extract error details from responses\n3. **Log requests**: Log webhook requests for debugging\n4. **Monitor usage**: Track credit consumption and costs\n\n## Example Usage\n\n### cURL\n\n```bash\ncurl -X POST \\\n  https://app.helpmaton.com/api/webhook/ws_123/agent_456/key_789 \\\n  -H \"Content-Type: text/plain\" \\\n  -d \"What is the weather today?\"\n```\n\n### JavaScript (Fetch API)\n\n```javascript\nasync function sendWebhook(workspaceId, agentId, key, message) {\n  const response = await fetch(\n    `https://app.helpmaton.com/api/webhook/${workspaceId}/${agentId}/${key}`,\n    {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"text/plain\",\n      },\n      body: message,\n    }\n  );\n\n  if (!response.ok) {\n    const error = await response.json();\n    throw new Error(error.error || \"Webhook request failed\");\n  }\n\n  return await response.json();\n}\n\n// Usage\nconst result = await sendWebhook(\n  \"ws_123\",\n  \"agent_456\",\n  \"key_789\",\n  \"What is the weather today?\"\n);\nconsole.log(result.response);\n```\n\n### Python (requests)\n\n```python\nimport requests\n\ndef send_webhook(workspace_id, agent_id, key, message):\n    url = f\"https://app.helpmaton.com/api/webhook/{workspace_id}/{agent_id}/{key}\"\n    response = requests.post(\n        url,\n        headers={\"Content-Type\": \"text/plain\"},\n        data=message\n    )\n    response.raise_for_status()\n    return response.json()\n\n# Usage\nresult = send_webhook(\n    \"ws_123\",\n    \"agent_456\",\n    \"key_789\",\n    \"What is the weather today?\"\n)\nprint(result[\"response\"])\n```\n\n## Streaming Alternative\n\nFor real-time streaming responses, use the streaming endpoint:\n\n```\nGET /api/streams/:workspaceId/:agentId/:secret\n```\n\nSee [Streaming System](./streaming-system.md) for details.\n\n## Troubleshooting\n\n### 401 Unauthorized\n\n- Verify the webhook key is correct\n- Check that the key belongs to the specified agent\n- Ensure the workspace ID matches\n\n### 402 Payment Required\n\n- Check workspace credit balance\n- Verify spending limits are not exceeded\n- Add credits to the workspace\n\n### 429 Too Many Requests\n\n- Reduce request frequency\n- Implement exponential backoff\n- Upgrade subscription plan for higher limits\n\n### 500 Internal Server Error\n\n- Check agent configuration\n- Verify LLM API key is valid\n- Review error logs for details\n\n## API Reference\n\nSee [API Reference](./api-reference.md) for complete endpoint documentation.\n",
};
