/**
 * HTTP to REST API Transformation Plugin
 * 
 * This plugin transforms HTTP API v2 integrations to REST API integrations
 * in the CloudFormation template generated by Architect.
 */

const { transformToRestApi } = require('./transform');

module.exports = {
  // Package hook runs after CloudFormation generation
  // It only receives cloudformation, so we'll need to extract stage from environment or cloudformation
  package: async ({ cloudformation }) => {
    // Only transform if HTTP API v2 is present
    const resources = cloudformation.Resources || {};
    const httpApi = resources.HTTP;
    
    
    // Check for AWS::Serverless::HttpApi (SAM format) or AWS::ApiGatewayV2::Api
    const isHttpApi = httpApi && (
      httpApi.Type === 'AWS::Serverless::HttpApi' || 
      httpApi.Type === 'AWS::ApiGatewayV2::Api'
    );
    
    if (!isHttpApi) {
      return cloudformation;
    }

    try {
      // Extract stage from environment or use default
      const stage = process.env.ARC_ENV || process.env.ARC_STAGE || 'staging';
      // Inventory might not be available in package hook, pass null
      const transformed = transformToRestApi(cloudformation, null, stage);
      
      // Debug: Log method URIs to help diagnose "Invalid ARN" errors
      if (process.env.DEBUG_TEMPLATE === 'true') {
        const methods = Object.entries(transformed.Resources || {})
          .filter(([_, resource]) => resource.Type === 'AWS::ApiGateway::Method');
        
        console.log('[http-to-rest] DEBUG: Method URIs after transformation:');
        for (const [methodId, method] of methods) {
          const uri = method.Properties?.Integration?.Uri;
          if (uri) {
            console.log(`[http-to-rest] DEBUG: ${methodId}:`, JSON.stringify(uri, null, 2));
            
            // Check for problematic patterns
            if (uri['Fn::Sub'] && typeof uri['Fn::Sub'] === 'string') {
              console.warn(`[http-to-rest] WARNING: ${methodId} still has string Fn::Sub format!`);
            }
            if (uri['Fn::Sub'] && Array.isArray(uri['Fn::Sub'])) {
              const uriString = uri['Fn::Sub'][0];
              if (uriString && uriString.includes('.Arn')) {
                console.warn(`[http-to-rest] WARNING: ${methodId} URI string still contains .Arn pattern:`, uriString);
              }
            }
          }
        }
        
        // Also check authorizer URIs
        const authorizers = Object.entries(transformed.Resources || {})
          .filter(([_, resource]) => resource.Type === 'AWS::ApiGateway::Authorizer');
        
        console.log('[http-to-rest] DEBUG: Authorizer URIs after transformation:');
        for (const [authId, authorizer] of authorizers) {
          const uri = authorizer.Properties?.AuthorizerUri;
          if (uri) {
            console.log(`[http-to-rest] DEBUG: ${authId}:`, JSON.stringify(uri, null, 2));
            
            if (uri['Fn::Sub'] && typeof uri['Fn::Sub'] === 'string') {
              console.warn(`[http-to-rest] WARNING: ${authId} still has string Fn::Sub format!`);
            }
            if (uri['Fn::Sub'] && Array.isArray(uri['Fn::Sub'])) {
              const uriString = uri['Fn::Sub'][0];
              if (uriString && uriString.includes('.Arn')) {
                console.warn(`[http-to-rest] WARNING: ${authId} URI string still contains .Arn pattern:`, uriString);
              }
            }
          }
        }
      }
      
      return transformed;
    } catch (error) {
      console.error('[http-to-rest] Error during HTTP to REST API transformation:', error);
      throw error;
    }
  },
  // Also keep deploy.start as fallback (runs before CloudFormation generation)
  deploy: {
    start: async ({ cloudformation, stage, inventory, arc }) => {
      // Only transform if HTTP API v2 is present
      const resources = cloudformation.Resources || {};
      const httpApi = resources.HTTP;
      
      
      // Check for AWS::Serverless::HttpApi (SAM format) or AWS::ApiGatewayV2::Api
      const isHttpApi = httpApi && (
        httpApi.Type === 'AWS::Serverless::HttpApi' || 
        httpApi.Type === 'AWS::ApiGatewayV2::Api'
      );
      
      if (!isHttpApi) {
        return cloudformation;
      }

      try {
        const transformed = transformToRestApi(cloudformation, inventory, stage);
        return transformed;
      } catch (error) {
        console.error('[http-to-rest] Error during HTTP to REST API transformation:', error);
        throw error;
      }
    },
  },
};
