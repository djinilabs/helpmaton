# HTTP v2 to REST API Transformation Plugin Plan

## Overview

This document outlines the plan for creating an Architect plugin that transforms HTTP API v2 integrations to REST API integrations in the CloudFormation template generated by Architect. The transformation will maintain all existing features, security policies, routes, and domain configurations with minimal changes.

## Current Architecture

### HTTP API v2 Structure (Current)

Architect currently generates HTTP API v2 resources with the following CloudFormation structure:

- **Main API Resource**: `AWS::ApiGatewayV2::Api` (resource ID: `HTTP`)
  - Properties include ProtocolType, Name, etc.
  - Custom domain configuration in `Properties.Domain`

- **Integrations**: `AWS::ApiGatewayV2::Integration`
  - Each HTTP route has an integration resource
  - Integration type: `AWS_PROXY` (Lambda proxy integration)
  - Integration URI points to Lambda function ARN

- **Routes**: `AWS::ApiGatewayV2::Route`
  - Route key (e.g., `GET /api/usage`, `ANY /api/auth/*`)
  - Target points to integration resource
  - Route selection expression

- **Stage**: `AWS::ApiGatewayV2::Stage`
  - Stage name (e.g., `staging`, `production`)
  - Auto-deploy enabled
  - Access log settings

- **Authorizers**: `AWS::ApiGatewayV2::Authorizer` (if any)
  - JWT, Lambda, or IAM authorizers

### Key Observations

1. The custom-domain plugin modifies `cloudformation.Resources.HTTP.Properties.Domain`
2. Architect uses resource naming patterns like `{Method}{Path}HTTPLambda` for Lambda functions
3. Routes are defined with route keys like `GET /api/usage` or `ANY /api/auth/*`
4. The handlers use `APIGatewayProxyEventV2` but have an adapter (`adaptHttpHandler`) that can handle REST events

## Target Architecture: REST API

### REST API Structure (Target)

The transformation will create REST API resources with:

- **Main API Resource**: `AWS::ApiGateway::RestApi`
  - Resource ID: `HTTP` (to maintain compatibility with existing plugins)
  - Properties include Name, Description, EndpointConfiguration

- **Resources**: `AWS::ApiGateway::Resource`
  - One resource per path segment (e.g., `/api`, `/api/usage`)
  - Parent-child relationships for nested paths

- **Methods**: `AWS::ApiGateway::Method`
  - HTTP method (GET, POST, ANY, etc.)
  - Integration type: `AWS_PROXY`
  - Integration URI points to Lambda function ARN
  - Request/response templates if needed

- **Deployment**: `AWS::ApiGateway::Deployment`
  - Links methods and resources together
  - Stage name reference

- **Stage**: `AWS::ApiGateway::Stage`
  - Stage name (e.g., `staging`, `production`)
  - Deployment reference
  - Access log settings

- **Domain Name**: `AWS::ApiGateway::DomainName` (if custom domain exists)
  - Certificate ARN
  - Domain name

- **Base Path Mapping**: `AWS::ApiGateway::BasePathMapping` (if custom domain exists)
  - Maps domain to REST API
  - Stage reference

- **Authorizers**: `AWS::ApiGateway::Authorizer` (if any)
  - JWT, Lambda, or IAM authorizers

## Transformation Strategy

### Phase 1: Resource Identification and Mapping

1. **Identify HTTP v2 Resources**
   - Locate `AWS::ApiGatewayV2::Api` resource (ID: `HTTP`)
   - Find all `AWS::ApiGatewayV2::Integration` resources
   - Find all `AWS::ApiGatewayV2::Route` resources
   - Find `AWS::ApiGatewayV2::Stage` resources
   - Identify any authorizers

2. **Map Routes to REST Resources**
   - Parse route keys (e.g., `GET /api/usage` → method: `GET`, path: `/api/usage`)
   - Create resource hierarchy for paths
   - Handle wildcards and catch-all routes (`/*`)

3. **Preserve Lambda Function References**
   - Maintain all Lambda function ARNs and references
   - Keep function permissions intact

### Phase 2: CloudFormation Template Transformation

The plugin will hook into Architect's `deploy.start` phase and transform the CloudFormation template:

```javascript
module.exports = {
  deploy: {
    start: async ({ cloudformation, stage, inventory, arc }) => {
      // Transformation logic here
      return cloudformation;
    }
  }
};
```

#### Transformation Steps

1. **Create REST API Resource**
   - Replace `AWS::ApiGatewayV2::Api` with `AWS::ApiGateway::RestApi`
   - Preserve API name and description
   - Set endpoint configuration (REGIONAL)

2. **Create Resource Hierarchy**
   - For each unique path, create `AWS::ApiGateway::Resource` resources
   - Build parent-child relationships
   - Handle root path (`/`) and nested paths

3. **Create Methods**
   - For each route, create `AWS::ApiGateway::Method` on the appropriate resource
   - Map HTTP methods (GET, POST, PUT, DELETE, ANY → all methods)
   - Set integration type to `AWS_PROXY`
   - Point integration URI to Lambda function

4. **Handle Catch-All Routes**
   - `ANY /*` routes become `AWS_PROXY` methods on a catch-all resource
   - Ensure proper resource hierarchy

5. **Create Deployment**
   - Create `AWS::ApiGateway::Deployment` resource
   - Reference all methods and resources
   - Add dependency on all method resources

6. **Create Stage**
   - Replace `AWS::ApiGatewayV2::Stage` with `AWS::ApiGateway::Stage`
   - Reference deployment
   - Preserve stage name, access logs, and other settings

7. **Transform Custom Domain** (if exists)
   - Replace `HTTP.Properties.Domain` structure
   - Create `AWS::ApiGateway::DomainName` resource
   - Create `AWS::ApiGateway::BasePathMapping` resource
   - Preserve certificate ARN and Route53 settings

8. **Transform Authorizers** (if any)
   - Convert `AWS::ApiGatewayV2::Authorizer` to `AWS::ApiGateway::Authorizer`
   - Update method authorizations to reference new authorizer

9. **Update Outputs**
   - Modify CloudFormation outputs to reference REST API
   - Update API endpoint URLs
   - Preserve custom domain outputs

10. **Clean Up**
    - Remove all HTTP v2 resources
    - Remove unused integrations and routes

### Phase 3: Handler Compatibility

The existing `adaptHttpHandler` utility already supports REST API events, so handlers should work without modification. However, verify:

1. Event transformation works correctly
2. Response format is compatible
3. Path parameters are correctly mapped
4. Query string parameters are preserved

## Implementation Details

### Plugin Structure

```
apps/backend/plugins/http-to-rest/
├── index.js              # Main plugin entry point
├── transform.js          # Core transformation logic
├── resources.js          # Resource creation utilities
├── methods.js            # Method creation utilities
├── domain.js             # Domain transformation logic
├── authorizers.js        # Authorizer transformation logic
├── utils.js              # Helper functions
└── PLAN.md               # This document
```

### Key Functions

#### `transform.js`

```javascript
/**
 * Main transformation function
 * @param {Object} cloudformation - CloudFormation template
 * @param {Object} inventory - Architect inventory
 * @returns {Object} Transformed CloudFormation template
 */
function transformToRestApi(cloudformation, inventory) {
  // 1. Identify HTTP v2 resources
  // 2. Create REST API resource
  // 3. Build resource hierarchy
  // 4. Create methods
  // 5. Create deployment and stage
  // 6. Transform domain (if exists)
  // 7. Transform authorizers (if any)
  // 8. Update outputs
  // 9. Clean up HTTP v2 resources
}
```

#### `resources.js`

```javascript
/**
 * Create REST API resource hierarchy from routes
 * @param {Array} routes - Array of route definitions
 * @returns {Object} Map of path to resource logical IDs
 */
function createResourceHierarchy(routes) {
  // Parse paths and create resource hierarchy
  // Handle wildcards and catch-all routes
}
```

#### `methods.js`

```javascript
/**
 * Create API Gateway Method resources
 * @param {Object} routes - Route definitions from HTTP v2
 * @param {Object} resourceMap - Path to resource ID mapping
 * @param {Object} integrations - Integration definitions
 * @returns {Array} Array of Method resource definitions
 */
function createMethods(routes, resourceMap, integrations) {
  // Create method for each route
  // Set integration type and URI
  // Handle ANY method (create all HTTP methods)
}
```

#### `domain.js`

```javascript
/**
 * Transform custom domain configuration
 * @param {Object} httpDomain - HTTP API v2 domain config
 * @param {string} restApiId - REST API resource ID
 * @returns {Object} REST API domain resources
 */
function transformDomain(httpDomain, restApiId) {
  // Create DomainName resource
  // Create BasePathMapping resource
  // Preserve Route53 settings
}
```

### Route Key Parsing

HTTP v2 route keys follow patterns:
- `GET /api/usage` → method: `GET`, path: `/api/usage`
- `POST /api/webhook/:workspaceId/:agentId/:key` → method: `POST`, path: `/api/webhook/{workspaceId}/{agentId}/{key}`
- `ANY /api/auth/*` → method: `ANY`, path: `/api/auth/*`
- `ANY /*` → method: `ANY`, path: `/*` (catch-all)

REST API uses:
- Path parameters: `{paramName}` instead of `:paramName`
- Wildcards: `{proxy+}` for catch-all
- Methods: `ANY` maps to all HTTP methods (GET, POST, PUT, DELETE, PATCH, HEAD, OPTIONS)

### Resource Naming

Maintain consistency with Architect's naming conventions:
- REST API: `HTTP` (same as HTTP v2, for plugin compatibility)
- Resources: `HTTP{PathSegment}Resource` (e.g., `HTTPApiResource`, `HTTPApiUsageResource`)
- Methods: `HTTP{PathSegment}{Method}Method` (e.g., `HTTPApiUsageGetMethod`)
- Deployment: `HTTPDeployment`
- Stage: `HTTP{Stage}Stage` (e.g., `HTTPStagingStage`)

## Testing Strategy

### Unit Tests

1. **Route Parsing**
   - Test parsing of various route key formats
   - Test wildcard and catch-all routes
   - Test path parameter extraction

2. **Resource Hierarchy**
   - Test creation of nested resource structures
   - Test handling of duplicate paths
   - Test catch-all resource placement

3. **Method Creation**
   - Test method creation for each HTTP method
   - Test ANY method expansion
   - Test integration URI mapping

4. **Domain Transformation**
   - Test domain name resource creation
   - Test base path mapping
   - Test Route53 configuration preservation

### Integration Tests

1. **Template Validation**
   - Validate transformed CloudFormation template
   - Check for missing dependencies
   - Verify resource references

2. **Deployment Testing**
   - Deploy to staging environment
   - Verify all routes work correctly
   - Test custom domain (if configured)
   - Verify Lambda integrations

3. **Handler Compatibility**
   - Test that existing handlers work with REST API events
   - Verify event transformation
   - Test path parameters, query strings, headers

## Migration Considerations

### Backward Compatibility

1. **Plugin Order**
   - This plugin should run before `custom-domain` plugin
   - Ensure `custom-domain` plugin works with REST API structure

2. **Existing Deployments**
   - First deployment will replace HTTP API v2 with REST API
   - This is a breaking change - API Gateway will be recreated
   - Plan for downtime or use blue-green deployment

3. **API Endpoints**
   - REST API endpoints have different format than HTTP API v2
   - Update any hardcoded endpoint references
   - Custom domains should remain the same

### Rollback Strategy

1. **Keep HTTP v2 Template**
   - Save original template before transformation
   - Ability to revert plugin if issues arise

2. **Feature Flag**
   - Consider adding environment variable to enable/disable transformation
   - Allows gradual rollout

## Security Considerations

1. **IAM Permissions**
   - Ensure Lambda execution roles remain unchanged
   - Verify API Gateway permissions are preserved

2. **Authorizers**
   - Test all authorizer types (JWT, Lambda, IAM)
   - Verify authorization logic works with REST API

3. **CORS**
   - REST API CORS configuration differs from HTTP v2
   - May need to add CORS method and headers explicitly

4. **Rate Limiting**
   - REST API uses usage plans and API keys
   - HTTP v2 uses throttling settings
   - Verify rate limiting behavior

## Performance Considerations

1. **Cold Start**
   - REST API may have slightly different cold start characteristics
   - Monitor Lambda invocation patterns

2. **Latency**
   - REST API and HTTP API v2 have similar latency
   - Monitor API response times after migration

3. **Cost**
   - REST API pricing differs from HTTP API v2
   - Review AWS pricing for both options
   - HTTP API v2 is generally cheaper

## Documentation Requirements

1. **Plugin README**
   - Installation instructions
   - Configuration options
   - Usage examples

2. **Migration Guide**
   - Step-by-step migration process
   - Pre-migration checklist
   - Post-migration verification

3. **Troubleshooting**
   - Common issues and solutions
   - How to debug transformation issues
   - Rollback procedures

## Implementation Phases

### Phase 1: Core Transformation (Week 1)
- [ ] Create plugin structure
- [ ] Implement REST API resource creation
- [ ] Implement resource hierarchy building
- [ ] Implement method creation
- [ ] Basic unit tests

### Phase 2: Advanced Features (Week 2)
- [ ] Domain transformation
- [ ] Authorizer transformation
- [ ] Output transformation
- [ ] Integration tests

### Phase 3: Testing and Validation (Week 3)
- [ ] Deploy to staging
- [ ] Test all routes
- [ ] Verify custom domain
- [ ] Performance testing
- [ ] Documentation

### Phase 4: Production Deployment (Week 4)
- [ ] Production deployment plan
- [ ] Monitoring setup
- [ ] Rollback procedures
- [ ] Production deployment

## References

- [Architect Plugin Documentation](https://arc.codes/docs/en/guides/plugins)
- [AWS API Gateway REST API CloudFormation Reference](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/AWS_ApiGateway.html)
- [AWS API Gateway HTTP API v2 CloudFormation Reference](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/AWS_ApiGatewayV2.html)
- [Architect Deploy Source Code](node_modules/.pnpm/@architect+deploy@5.0.8/node_modules/@architect/deploy)

## Notes

- The `adaptHttpHandler` utility in `apps/backend/src/utils/httpEventAdapter.ts` already supports REST API events, so handlers should work without modification
- The `custom-domain` plugin modifies `cloudformation.Resources.HTTP.Properties.Domain` - this will need to be updated to work with REST API domain resources
- Consider the cost implications: HTTP API v2 is generally cheaper than REST API
- REST API has more features (request/response transformations, more authorizer options) but HTTP API v2 is simpler and faster

