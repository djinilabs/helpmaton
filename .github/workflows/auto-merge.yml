name: Auto Merge

on:
  workflow_run:
    workflows: ["Tests", "Deploy PR", "E2E Tests"]
    types:
      - completed
    branches:
      - "**" # Run for all branches (PRs)
  schedule:
    # Run every hour at minute 30 to check for PRs ready to merge (fallback)
    - cron: "30 * * * *" # Every hour at minute 30

jobs:
  auto-merge:
    name: Auto Merge PR
    runs-on: ubuntu-latest
    # Security: Explicit permissions - only what's needed
    # Note: These write permissions are required for auto-merge functionality
    permissions:
      contents: write
      pull-requests: write
      checks: read
      statuses: read
      actions: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Get PR number(s) to check
        id: pr-info
        uses: actions/github-script@v8
        with:
          script: |
            const eventName = context.eventName;
            console.log(`Event: ${eventName}`);

            let prNumbers = [];

            if (eventName === 'workflow_run') {
              // Get PR from workflow_run event
              const workflowRun = context.payload.workflow_run;
              const headSha = workflowRun.head_sha;
              const headBranch = workflowRun.head_branch;
              
              console.log(`Workflow run completed: ${workflowRun.name}`);
              console.log(`Head SHA: ${headSha}`);
              console.log(`Head branch: ${headBranch}`);
              console.log(`Conclusion: ${workflowRun.conclusion}`);
              
              // Only process if workflow completed successfully
              if (workflowRun.conclusion !== 'success') {
                console.log(`Workflow did not complete successfully (${workflowRun.conclusion}), skipping auto-merge check.`);
                core.setOutput('pr_numbers', '');
                return;
              }
              
              // Check if this workflow run was for a PR
              if (workflowRun.pull_requests && workflowRun.pull_requests.length > 0) {
                // Get PR numbers from workflow run
                prNumbers = workflowRun.pull_requests.map(pr => pr.number);
                console.log(`Found PRs from workflow_run: ${prNumbers.join(', ')}`);
              } else {
                // Try to find PR by commit SHA
                const { data: allPrs } = await github.rest.pulls.list({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  state: 'open',
                });
                
                for (const pr of allPrs) {
                  if (pr.head.sha === headSha) {
                    prNumbers.push(pr.number);
                    break;
                  }
                }
              }
              
              if (prNumbers.length > 0) {
                core.setOutput('pr_numbers', prNumbers.join(','));
                core.setOutput('head_sha', headSha);
              } else {
                console.log(`No open PR found for workflow run. This might be a direct push to main.`);
              }
            } else if (eventName === 'schedule') {
              // Scheduled run - check all open PRs from Renovate bot
              console.log('Scheduled run - checking all open PRs from Renovate bot...');
              
              const { data: allPrs } = await github.rest.pulls.list({
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'open',
              });
              
              for (const pr of allPrs) {
                const authorLogin = pr.user.login;
                if (authorLogin === 'app/renovate' || authorLogin === 'renovate[bot]') {
                  prNumbers.push(pr.number);
                }
              }
              
              console.log(`Found ${prNumbers.length} open PR(s) from Renovate bot: ${prNumbers.join(', ')}`);
              core.setOutput('pr_numbers', prNumbers.join(','));
            }

            if (prNumbers.length === 0) {
              core.setOutput('pr_numbers', '');
            }

      - name: Skip if no PRs to check
        if: steps.pr-info.outputs.pr_numbers == ''
        run: |
          echo "No PRs found to check. Skipping auto-merge."
          exit 0

      - name: Check if PRs are ready for merge
        id: check-status
        uses: actions/github-script@v8
        with:
          script: |
            const prNumbersStr = '${{ steps.pr-info.outputs.pr_numbers }}';
            const prNumbers = prNumbersStr ? prNumbersStr.split(',').map(n => parseInt(n.trim())) : [];

            console.log(`Checking ${prNumbers.length} PR(s) for merge readiness...`);

            const readyPRs = [];

            for (const prNumber of prNumbers) {
              console.log(`\n=== Checking PR #${prNumber} ===`);
              
              try {
                // Get PR details
                const { data: pr } = await github.rest.pulls.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: prNumber,
                });
                
                console.log(`PR state: ${pr.state}`);
                console.log(`PR author: ${pr.user.login}`);
                console.log(`PR mergeable: ${pr.mergeable}`);
                console.log(`PR mergeable_state: ${pr.mergeable_state}`);
                
                // Check if PR is already merged or closed
                if (pr.state !== 'open') {
                  console.log(`PR is ${pr.state}, skipping`);
                  continue;
                }
                
                // Check if PR author is Renovate bot
                const authorLogin = pr.user.login;
                const isRenovateBot = authorLogin === 'app/renovate' || authorLogin === 'renovate[bot]';
                
                if (!isRenovateBot) {
                  console.log(`PR author is ${authorLogin}, not Renovate bot. Skipping.`);
                  continue;
                }
                
                // Check if ALL commits are from Renovate bot (both author and committer)
                // This ensures Renovate is the ONLY committer on the PR
                const { data: commits } = await github.rest.pulls.listCommits({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: prNumber,
                });
                
                if (commits.length === 0) {
                  console.log('PR has no commits. Skipping.');
                  continue;
                }
                
                // Collect all unique committers (both author and committer)
                const uniqueCommitters = new Set();
                let allCommitsFromRenovate = true;
                
                for (const commit of commits) {
                  // Check commit author
                  const commitAuthor = commit.author?.login || commit.commit.author.name;
                  const commitAuthorEmail = commit.commit.author.email || '';
                  
                  // Check commit committer
                  const commitCommitter = commit.committer?.login || commit.commit.committer.name;
                  const commitCommitterEmail = commit.commit.committer.email || '';
                  
                  // Check if author is Renovate bot
                  const isAuthorRenovate = 
                    commitAuthor === 'app/renovate' || 
                    commitAuthor === 'renovate[bot]' ||
                    commitAuthor === 'renovate' ||
                    commitAuthorEmail.includes('renovate');
                  
                  // Check if committer is Renovate bot
                  const isCommitterRenovate = 
                    commitCommitter === 'app/renovate' || 
                    commitCommitter === 'renovate[bot]' ||
                    commitCommitter === 'renovate' ||
                    commitCommitterEmail.includes('renovate');
                  
                  if (!isAuthorRenovate || !isCommitterRenovate) {
                    console.log(`Commit ${commit.sha.substring(0, 7)}: author=${commitAuthor}, committer=${commitCommitter} - not from Renovate bot`);
                    allCommitsFromRenovate = false;
                    break;
                  }
                  
                  // Track unique committers
                  if (commitAuthor) uniqueCommitters.add(commitAuthor);
                  if (commitCommitter) uniqueCommitters.add(commitCommitter);
                }
                
                if (!allCommitsFromRenovate) {
                  console.log('Not all commits are from Renovate bot. Skipping.');
                  continue;
                }
                
                // Verify Renovate is the ONLY committer
                const renovateIdentifiers = ['app/renovate', 'renovate[bot]', 'renovate'];
                const hasOnlyRenovateCommitters = Array.from(uniqueCommitters).every(committer => 
                  renovateIdentifiers.some(id => committer.includes(id))
                );
                
                if (!hasOnlyRenovateCommitters) {
                  console.log(`PR has committers other than Renovate: ${Array.from(uniqueCommitters).join(', ')}. Skipping.`);
                  continue;
                }
                
                console.log(`‚úÖ All commits verified: only Renovate bot commits found (${commits.length} commit(s))`);
                
                // Get branch protection rules to find required checks
                let requiredChecks = [];
                try {
                  const { data: protection } = await github.rest.repos.getBranchProtection({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    branch: pr.base.ref,
                  });
                  
                  if (protection.required_status_checks) {
                    if (protection.required_status_checks.contexts) {
                      requiredChecks = protection.required_status_checks.contexts;
                      console.log(`Required checks from branch protection: ${requiredChecks.join(', ')}`);
                    } else if (protection.required_status_checks.strict) {
                      console.log('Branch protection has strict mode enabled - checking all status checks');
                    }
                  }
                } catch (error) {
                  if (error.status === 404) {
                    console.log('No branch protection rules found. Will check all status checks.');
                  } else {
                    console.log(`Error fetching branch protection: ${error.message}`);
                  }
                }
                
                // Get all check runs for the PR head commit
                const headSha = pr.head.sha;
                const { data: checkRuns } = await github.rest.checks.listForRef({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: headSha,
                });
                
                console.log(`Found ${checkRuns.total_count} check runs for commit ${headSha}`);
                
                // Filter to required checks if we have them, otherwise check all
                const checksToVerify = requiredChecks.length > 0 
                  ? checkRuns.check_runs.filter(cr => requiredChecks.includes(cr.name))
                  : checkRuns.check_runs;
                
                console.log(`Checking ${checksToVerify.length} check(s)...`);
                
                // Check if all required checks have passed
                const pendingChecks = [];
                const failedChecks = [];
                
                for (const checkRun of checksToVerify) {
                  console.log(`Check: ${checkRun.name} - Status: ${checkRun.status}, Conclusion: ${checkRun.conclusion}`);
                  
                  if (checkRun.status !== 'completed') {
                    pendingChecks.push(checkRun.name);
                  } else if (checkRun.conclusion !== 'success') {
                    failedChecks.push(checkRun.name);
                  }
                }
                
                if (pendingChecks.length > 0) {
                  console.log(`Pending checks: ${pendingChecks.join(', ')}`);
                  continue;
                }
                
                if (failedChecks.length > 0) {
                  console.log(`Failed checks: ${failedChecks.join(', ')}`);
                  continue;
                }
                
                // Check PR mergeability
                if (pr.mergeable !== true) {
                  console.log(`PR is not mergeable (mergeable: ${pr.mergeable})`);
                  continue;
                }
                
                if (pr.mergeable_state !== 'clean') {
                  console.log(`PR merge state is not clean (${pr.mergeable_state})`);
                  continue;
                }
                
                console.log(`‚úÖ PR #${prNumber} is ready for auto-merge!`);
                readyPRs.push(prNumber);
              } catch (error) {
                console.log(`Error checking PR #${prNumber}: ${error.message}`);
              }
            }

            if (readyPRs.length > 0) {
              console.log(`\n‚úÖ Found ${readyPRs.length} PR(s) ready for merge: ${readyPRs.join(', ')}`);
              core.setOutput('ready_prs', readyPRs.join(','));
            } else {
              console.log('\n‚ùå No PRs are ready for merge.');
              core.setOutput('ready_prs', '');
            }

      - name: Auto merge PRs
        if: steps.check-status.outputs.ready_prs != ''
        run: |
          READY_PRS="${{ steps.check-status.outputs.ready_prs }}"

          # Split comma-separated PR numbers
          IFS=',' read -ra PR_ARRAY <<< "$READY_PRS"

          for PR_NUMBER in "${PR_ARRAY[@]}"; do
            PR_NUMBER=$(echo "$PR_NUMBER" | xargs) # trim whitespace
            echo ""
            echo "=== Attempting to merge PR #${PR_NUMBER} ==="
            
            # Retry logic with exponential backoff
            MAX_ATTEMPTS=5
            attempt=1
            merged=false
            
            while [ $attempt -le $MAX_ATTEMPTS ] && [ "$merged" = false ]; do
              echo "Merge attempt ${attempt}/${MAX_ATTEMPTS}..."
              
              if gh pr merge $PR_NUMBER --auto --squash; then
                echo "‚úÖ PR #${PR_NUMBER} merged successfully"
                merged=true
                
                # Comment on PR
                gh pr comment $PR_NUMBER --body "ü§ñ **Auto-merge completed!** This Renovate bot PR has been automatically merged after all required checks passed."
              else
                EXIT_CODE=$?
                echo "‚ùå Merge attempt ${attempt} failed with exit code ${EXIT_CODE}"
                
                if [ $attempt -lt $MAX_ATTEMPTS ]; then
                  WAIT_TIME=$((2 ** $attempt))
                  echo "Waiting ${WAIT_TIME} seconds before retry..."
                  sleep $WAIT_TIME
                else
                  echo "‚ùå Failed to merge PR #${PR_NUMBER} after ${MAX_ATTEMPTS} attempts"
                fi
              fi
              attempt=$((attempt + 1))
            done
            
            if [ "$merged" = false ]; then
              echo "‚ö†Ô∏è  Skipping PR #${PR_NUMBER} due to merge failure"
            fi
          done
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
