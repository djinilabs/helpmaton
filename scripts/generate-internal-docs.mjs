#!/usr/bin/env node
/**
 * Generates apps/backend/src/utils/internalDocs.ts from docs/*.md.
 * Only includes docs in the whitelist (customer-service–relevant).
 * Run before backend build so Lambda has index + content at runtime.
 */

import { readFile, writeFile, mkdir } from "fs/promises";
import { join, dirname } from "path";
import { fileURLToPath } from "url";

const __dirname = dirname(fileURLToPath(import.meta.url));
const repoRoot = join(__dirname, "..");
const docsDir = join(repoRoot, "docs");
const utilsDir = join(repoRoot, "apps", "backend", "src", "utils");
const outIndexPath = join(utilsDir, "internalDocsIndex.ts");
const outContentPath = join(utilsDir, "internalDocsContent.ts");
const outReexportPath = join(utilsDir, "internalDocs.ts");

/** Doc ids (filename without .md) that are customer-service relevant. */
const WHITELIST = [
  "getting-started",
  "agent-configuration",
  "document-management",
  "workspace-permissions",
  "api-reference",
  "pricing",
  "troubleshooting",
  "authentication",
  "subscription-management",
  "mcp-servers",
  "credit-system",
  "webhook-system",
];

function extractTitle(content) {
  const match = content.match(/^#\s+(.+)$/m);
  if (match) return match[1].trim();
  return null;
}

function extractOneLine(content) {
  const lines = content.split(/\r?\n/);
  for (const line of lines) {
    const t = line.trim();
    if (!t) continue;
    if (t.startsWith("#")) continue;
    return t.length > 120 ? t.slice(0, 117) + "..." : t;
  }
  return "No description";
}

async function main() {
  const index = [];
  const contentEntries = [];

  for (const id of WHITELIST) {
    const filePath = join(docsDir, `${id}.md`);
    let raw;
    try {
      raw = await readFile(filePath, "utf-8");
    } catch (err) {
      if (err.code === "ENOENT") {
        console.warn(`[generate-internal-docs] Skipping missing doc: ${id}.md`);
        continue;
      }
      throw err;
    }

    const title = extractTitle(raw) || id.replace(/-/g, " ").replace(/\b\w/g, (c) => c.toUpperCase());
    const oneLine = extractOneLine(raw);

    index.push({ id, title, oneLine });
    contentEntries.push({ id, content: raw });
  }

  const indexLines = index
    .map((e) => `  { id: ${JSON.stringify(e.id)}, title: ${JSON.stringify(e.title)}, oneLine: ${JSON.stringify(e.oneLine)} },`)
    .join("\n");

  if (index.length === 0) {
    console.error("[generate-internal-docs] No docs produced; all whitelist files missing?");
    process.exit(1);
  }

  const contentLines = contentEntries
    .map((e) => `  ${JSON.stringify(e.id)}: ${JSON.stringify(e.content)},`)
    .join("\n");

  const indexOut = `/**
 * Generated by scripts/generate-internal-docs.mjs — do not edit by hand.
 * Index only (small); content is in internalDocsContent.ts for lazy loading.
 */

export type InternalDocEntry = {
  id: string;
  title: string;
  oneLine: string;
};

export const INTERNAL_DOCS_INDEX: InternalDocEntry[] = [
${indexLines}
];

/** One line per doc for system prompt: "- [id] title — oneLine" */
export function getInternalDocsIndexForPrompt(): string {
  return INTERNAL_DOCS_INDEX.map(
    (e) => \`- [\${e.id}] \${e.title} — \${e.oneLine}\`
  ).join("\\n");
}
`;

  const contentOut = `/**
 * Generated by scripts/generate-internal-docs.mjs — do not edit by hand.
 * Content only; loaded lazily when read_internal_doc is used.
 */

export const INTERNAL_DOCS_CONTENT: Record<string, string> = {
${contentLines}
};
`;

  const reexportOut = `/**
 * Generated by scripts/generate-internal-docs.mjs — do not edit by hand.
 * Re-exports index and content for backward compatibility (e.g. tests).
 */

export * from "./internalDocsIndex";
export * from "./internalDocsContent";
`;

  await mkdir(utilsDir, { recursive: true });
  await writeFile(outIndexPath, indexOut, "utf-8");
  await writeFile(outContentPath, contentOut, "utf-8");
  await writeFile(outReexportPath, reexportOut, "utf-8");
  console.log(`[generate-internal-docs] Wrote ${index.length} docs to ${outIndexPath}, ${outContentPath}, ${outReexportPath}`);
}

main().catch((err) => {
  console.error(err);
  process.exit(1);
});
