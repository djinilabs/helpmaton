#!/usr/bin/env node
/**
 * Generates apps/backend/src/utils/internalDocs.ts from docs/*.md.
 * Only includes docs in the whitelist (customer-service–relevant).
 * Run before backend build so Lambda has index + content at runtime.
 */

import { readFile, writeFile, mkdir } from "fs/promises";
import { join, dirname } from "path";
import { fileURLToPath } from "url";

const __dirname = dirname(fileURLToPath(import.meta.url));
const repoRoot = join(__dirname, "..");
const docsDir = join(repoRoot, "docs");
const outPath = join(repoRoot, "apps", "backend", "src", "utils", "internalDocs.ts");

/** Doc ids (filename without .md) that are customer-service relevant. */
const WHITELIST = [
  "getting-started",
  "agent-configuration",
  "document-management",
  "workspace-permissions",
  "api-reference",
  "pricing",
  "troubleshooting",
  "authentication",
  "subscription-management",
  "mcp-servers",
  "credit-system",
  "webhook-system",
];

function extractTitle(content) {
  const match = content.match(/^#\s+(.+)$/m);
  if (match) return match[1].trim();
  return null;
}

function extractOneLine(content) {
  const lines = content.split(/\r?\n/);
  for (const line of lines) {
    const t = line.trim();
    if (!t) continue;
    if (t.startsWith("#")) continue;
    return t.length > 120 ? t.slice(0, 117) + "..." : t;
  }
  return "No description";
}

async function main() {
  const index = [];
  const contentEntries = [];

  for (const id of WHITELIST) {
    const filePath = join(docsDir, `${id}.md`);
    let raw;
    try {
      raw = await readFile(filePath, "utf-8");
    } catch (err) {
      if (err.code === "ENOENT") {
        console.warn(`[generate-internal-docs] Skipping missing doc: ${id}.md`);
        continue;
      }
      throw err;
    }

    const title = extractTitle(raw) || id.replace(/-/g, " ").replace(/\b\w/g, (c) => c.toUpperCase());
    const oneLine = extractOneLine(raw);

    index.push({ id, title, oneLine });
    contentEntries.push({ id, content: raw });
  }

  const indexLines = index
    .map((e) => `  { id: ${JSON.stringify(e.id)}, title: ${JSON.stringify(e.title)}, oneLine: ${JSON.stringify(e.oneLine)} },`)
    .join("\n");

  if (index.length === 0) {
    console.error("[generate-internal-docs] No docs produced; all whitelist files missing?");
    process.exit(1);
  }

  const contentLines = contentEntries
    .map((e) => `  ${JSON.stringify(e.id)}: ${JSON.stringify(e.content)},`)
    .join("\n");

  const out = `/**
 * Generated by scripts/generate-internal-docs.mjs — do not edit by hand.
 * Customer-support–relevant internal docs index and content for workspace/meta-agent.
 */

export type InternalDocEntry = {
  id: string;
  title: string;
  oneLine: string;
};

export const INTERNAL_DOCS_INDEX: InternalDocEntry[] = [
${indexLines}
];

export const INTERNAL_DOCS_CONTENT: Record<string, string> = {
${contentLines}
};

/** One line per doc for system prompt: "- [id] title — oneLine" */
export function getInternalDocsIndexForPrompt(): string {
  return INTERNAL_DOCS_INDEX.map(
    (e) => \`- [\${e.id}] \${e.title} — \${e.oneLine}\`
  ).join("\\n");
}
`;

  await mkdir(dirname(outPath), { recursive: true });
  await writeFile(outPath, out, "utf-8");
  console.log(`[generate-internal-docs] Wrote ${index.length} docs to ${outPath}`);
}

main().catch((err) => {
  console.error(err);
  process.exit(1);
});
